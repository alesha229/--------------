{
  "topics": {
    "intro_js": true,
    "specifications": true,
    "code_editors": true,
    "dev_console": true,
    "variables": true,
    "data_types": true,
    "interaction": true,
    "type_conversions": true,
    "operators": true,
    "comparison": true,
    "ifelse": true,
    "logical_operators": true,
    "nullish": true,
    "loops": true,
    "switch": true,
    "functions": true,
    "function_expressions": true,
    "arrow_functions": true,
    "debugging": true,
    "coding_style": true,
    "comments": true,
    "ninja_code": true,
    "testing": true,
    "polyfills": true,
    "object_basics": true,
    "object_copy": true,
    "garbage_collection": true,
    "object_methods": true,
    "constructor_new": true,
    "optional_chaining": true,
    "symbol": true,
    "object_to_primitive": true,
    "primitives_methods": true,
    "numbers": true,
    "strings": true,
    "arrays": true,
    "array_methods": true,
    "iterables": true,
    "map_set": true,
    "weakmap_weakset": true,
    "keys_values_entries": true,
    "destructuring": true,
    "date_time": true,
    "json": true,
    "recursion": true,
    "rest_spread": true,
    "closure": true,
    "var": true,
    "global_object": true,
    "function_object": true,
    "new_function": true,
    "settimeout_setinterval": true,
    "call_apply_decorators": true,
    "bind": true,
    "arrow_functions_revisited": true,
    "property_descriptors": true,
    "property_accessors": true,
    "prototype_inheritance": true,
    "function_prototype": true,
    "native_prototypes": true,
    "prototype_methods": true,
    "class_basic": true,
    "class_inheritance": true,
    "static_properties_methods": true,
    "private_protected": true,
    "extend_natives": true,
    "instanceof": true,
    "mixins": true,
    "try_catch": true,
    "custom_errors": true,
    "callbacks": true,
    "promise_basics": true,
    "promise_chaining": true,
    "promise_error_handling": true,
    "promise_api": true,
    "promisification": true,
    "microtasks": true,
    "async_await": true
  },
  "diary": [
    {
      "date": "2024-12-11",
      "content": "PROTOTYPE\n\nСегодня изучил свойство prototype то есть у каждого объекта есть свой прототип и мы можем использовать методы и значения в родительском прототипе а у этого прототипа может быть выше родитель, и так если мы вызвали какой-то метод и в нашем объекте такого нет то js ищет в прототипе этот метод, если не нашел то в прототипе прототипа и т.д пока не дойдет до null.\n\nCONTEXT .this\nТак же разобрался как работает контекст. Что такое вообще контекст это \"среда\" выполнения функции или методы то есть конкретные методы или же значения которые нам доступны по ссылке .this . Как же с ним работать? Контекст у нас создается при вызове функции/метода того объекта или функции у которой они были вызваны. Но если мы запишем функцию/метод в переменную и вызовем её после то контекст у нас будет потерян. Для решения этой проблемы или задания другого контекста мы можем использовать .bind .apply .call\nих отличия в том что .bind не вызывает функцию но задает контекст и может передавать аргументы, .apply и .call почти одно и тоже они так же задают контекст но исполняют функцию/метод их отличия в том что .apply принимает на вход массив аргументов.\n\nCLASS\nРазобрался и посмотрел принципы ООП конкретно в JS и как их реализовать. Что такое класс, это пользовательский тип который имеет собственные методы и конструктор, классы могут наследоваться для реализации принципов ООП. \n\nЧто такое конструктор класса, это специальный метод который задает и создает новый экземпляр объекта класса при инициализации. То есть что он делает на вход подаются параметры и конструктор уже заполняет поля класса, может использовать для этого методы класса. То есть нужно различать что такое конструктор и что такое поле класса. Поле класса это данные которые мы в нем храним. А конструктор устанавливает значения всем этим полям. (Поле может быть приватным используя префикс # об этом в ниже)\n\n\nИнкапсуляция это принцип когда мы объединяем методы и данные для работы в одном классе для сокрытия реализации, так же к этому относиться #private поля то есть извне класса не можем получить их, только методы внутри класса могут их использовать.\n\nАбстракция это принцип когда мы описываем методы в классе но отдаем её реализацию наследуемым классам то есть у нас есть минимальное описание метода в родителе для понимания что этот метод должен делать \"абстракция\" и наследуемый класс реализует этот метод конкретизируя что этот метод делает.\n\nНаследование это принцип это когда мы создаем новый класс на основе родительского используя методы и данные из родителя.\n\nПолиморфизм это принцип когда мы можем работать с разными типами объектов через общий интерфейс(интерфейс это метод) \n(Не очень разобрался в теме так что прикреплю пример)\n\n```\nclass Animal {\n    makeSound() {\n        return \"Какой-то звук\";\n    }\n}\n\nclass Dog extends Animal {\n    makeSound() {\n        return \"Гав!\";\n    }\n}\n\nclass Cat extends Animal {\n    makeSound() {\n        return \"Мяу!\";\n    }\n}\n\n// Функция работает с любым животным\nfunction animalSound(animal) {\n    console.log(animal.makeSound());\n}\n\nlet dog = new Dog();\nlet cat = new Cat();\n\nanimalSound(dog); // \"Гав!\"\nanimalSound(cat); // \"Мяу!\"\n```\n\nSUPER\nТак же разобрался с ключевым словом super. Super используется для доступа к полям и методам родителя то есть мы указываем что мы используем поля и методы родителя а не дочернего класса. То есть у нас есть два класса родительский и дочерний и у нас есть одинаковые поля/методы в них и при использовании super.say() будет использован метод родительского класса, так же работает и с полями.\n\n\nPromise async await\nПосмотрел и поделал примеры с promise. Что такое promise это объект ожидающий асинхронного выполнения операции. То есть внутри promise мы выполняем асинхронные операции как пример это setTimeout(), Fetch, функции с префиксом async - это означает то что функция выполняется асинхронно. Асинхронность если просто объяснить то это когда выполнение кода не блокируется то есть мы не ждем выполнения команды(строки) относительно синхронного кода. Синхронность это когда мы ждем выполнения команды чтобы выполнить следующую . await это команда ожидания выполнения асинхронной операции т.е он останавливает выполнение функции пока она не выполниться. \n\nТак же затронул темы замыкания, области видимости ликсической области видимости, и всплытие. Но пока резюмировать не могу с точностью."
    },
    {
      "date": "2024-12-12",
      "content": "Что такое замыкания, это функция которая запоминает внешние значения которые могут быть изменены только при помощи специальных методов внутри неё т.е переменная внутри функции при создании лексического окружения \"защищена\" от доступа из вне(чтение/запись).\n\n```У такой функции есть лексическая зона видимости, т.е её значения перекрывают глобальные и из другого лексического окружения её не видно.\nКак задать новое лексическое окружение?\nconst counter1 = createCounter();\nconst counter2 = createCounter()\n\nДанные экземпляры функций создали свое лексическое окружение и не имеют доступ к полям друг друга.\n\nПри повторном вызове экземпляра функции в одном и том же лексическом окружении значения полей сохраняются.\n\nЧто такое лексическое окружение? Это область(scope) переменных, оно создается каждый раз когда выполняется функция или создается блок кода(например в условии или цикле)```\n\nОШИБОЧНОЕ СУЖДЕНИЕ\n\nПопробуем ещё раз объяснить\nЛексическое окружение создается когда мы объявляем функцию.\n\n```function createGreeting(name) {\n    // Лексическое окружение создается ЗДЕСЬ\n    // В этот момент \"запоминаются\" все доступные переменные\n    return function() {\n        console.log(`Привет, ${name}!`);\n    };\n}\n\nconst greetIvan = createGreeting('Иван');\nconst greetMaria = createGreeting('Мария');\n\n// greetIvan и greetMaria - разные экземпляры,\n// но с разными лексическими окружениями```\n\nВот пример \n```const greetIvan = createGreeting('Иван');\nconst greetMaria = createGreeting('Мария');\n```\nВ данном случае это будет правильно работать НО! именно в этом участке происходит объявление функции т.к как результат выполнения функции createGreeting это другая функция\n```    return function() {\n        console.log(`Привет, ${name}!`);\n    };\n```\nМы исполняем и передаем в лексическое окружение createGreeting 'Иван' поле name и дальше эта функция возвращает другую функцию и в объявлении этой функции когда greetIvan = createGreeting  у нас создается лексическое окружение функции которую мы вернули. У неё родитель это createGreeting где есть поле name = 'Иван'. Далее мы ещё раз вызываем и изменяем переменную внутри функции createGreeting name = \"Мария\" и опять возвращаем функцию и там где мы вызывали эту функцию мы её объявляем и у нас создается второе лексическое окружение у которой опять же родитель createGreeting и где name = 'Иван' \n\nТо есть по итогу у каждого из двух полученых лексических окружений новых ссылка на name сохраняется в их лексическое окружение \nВАЖНО!!!\n\nЗначения переменных фиксируются при ВЫЗОВЕ\n\n```// Лексическое окружение greetIvan\n{\n    [[Environment]]: {\n        name: 'Иван',  // Сохраненная ссылка\n        parentContext: GlobalEnvironment\n    }\n}\n\n// Лексическое окружение greetMaria\n{\n    [[Environment]]: {\n        name: 'Мария', // Отдельная сохраненная ссылка\n        parentContext: GlobalEnvironment\n    }\n}\n```\n\nКак я разобрал пример Эда с комментариями\n\n```\nfunction createGreeting(name) {\n  // это объявление функции = создание лексического окружения, в нем у нас есть name(внутри createGreeting)\n\n  return function () {\n    console.log(`Привет, ${name}`);// при вызове функции createGreeting мы возвращаем функцию но ещё НЕ объявляем функцию!\n  };\n}\n\nconst b = function () {\n  // функция b объявлена в глобальном лексичеком окружении а не в лексическом окружении createGreeting\n  console.log(`Привет, ${name}`);\n};\n\nfunction createGreeting2(name) {\n  // так же объявляем функцию и возвращаем функцию b\n  // при возврате функции мы не объявляем её внутри createGreeting2 а возвращаем ссылку на функцию которая объявлена в глобальном\n  //лексичесом окружении\n  return b;\n}\n\nvar name = \"Бла-Бла\"; //задаем name в глобальном лексическом окружении\n\nconst greetIvan = createGreeting(\"Иван\")();\n//() - исполнение функции,\n//const greetIvan = createGreeting('Иван') - объявление функции\n//как результат работы функции мы получаем ссылку на функцию внутри createGreetitng\n//после чего при помощи = мы объявляем её т.е это могло бы выглядит так\n//const greetIvan = function () {\n//     console.log(`Привет, ${name}`);\n// };\n//НО! в таком случае мы объявили функцию в глобальном лексическом окружении а не в лексическом окружении createGreeting\n//И следствие этого что у нас нет доступа к name лексического окружения createGreeting\n\n//Да мы объявляем дочернюю функцию и у неё создается СВОЁ лексическоое окружение и если у него нет name то оно ищет его выше и выше\n//по иерархии \n\nconst greetIvan2 = createGreeting2(\"Иван\")();\n//() - исполнение функции,\n//const greetIvan = createGreeting2('Иван') - объявление функции\n//В данном случае объявление в глобальном лексическом окружении происходит(там где было объявлено b)\n\n\n//Как послесловие могу сказать что лексическое окружение относится не только к функциям но и к блокам кода таким как if, for\n//блок кода это то что находиться внутри {} можно сказать что объявление блока кода = объявлению функции\n//это важно понимать особенно для for\n```"
    },
    {
      "date": "2024-12-12",
      "content": "Краткое резюме по всем вопросам\n1.Типы данных примитивные и передаваемые по ссылке\nПримитивные\nstring\nnumber\nboolean\nnull\nundefiend\nbigInt\nПередаваемые по ссылке\nэто object но в него входят много подтипов\nfunction\narray\ndate\nregExp\nи пр.\n\n2.Оператор typeof у нас возвращает тип передаваемого в него данных ответ приходит строкой\nВ случае проверки null то он возвращает = object это ошибка языка js\n\n3.var let и const это переменные, var устаревший тип записи переменной, т.к он имеет нежелательное свойство то что она имеет глобальную область видимости в то время как let и const блочную, const это переменная которую нельзя изменять. Всплытие переменных это когда мы обращаемся к переменной до их вызова var выдаст undefiend а let и const referenceError: is not initialized Но ссылка будет создана.\n\n4.Функция это блок кода который принимает на вход параметры и возвращает результат работы. Для чего оны нужны и используются? Функцию можно и нужно переиспользовать, чтобы не повторять код, функцию можно вызвать как конструктор которая возвращает объект с полями и методами этой функции, при помощи функций мы можем организовать код то есть разделять ответственность и пр. .\n\n5.Контекст функции у нас определяется во время её вызова, если мы используем функцию как конструктор то контекст будет так же доступен через .this. Контекст по умолчанию у нас берется  из самой функции но мы можем его потерять или же задать другой. Контекст потеряется если мы запишем функцию в переменную и попробуем вызвать её то контекст у нас будет пустой. Мы можем его задать при помощи .bind .apply .call\n\n6.При вызове функции как конструктора с использованием оператора new  она возвращает объект у которого сохраняются все поля и методы функции. Так же у каждого объекта есть прототип, и мы можем задавать цепочку прототипов при помощи .prototype или же setPrototypeOf. Прототип это свойство которое задает связь с прототипами объекта, для чего он нужен, если мы обращаемся к объекту то ему передаются все поля и методы прототипа и так же у прототипа который мы указали может быть свой прототип и так образуется цепочка прототипов, при вызове метода или поля смотрится вся цепочка прототипов пока не дойдет до null на нахождение того или иного поля или метода начиная с изначального объекта.\n\n7.bind метод который возвращает функцию с заданным контекстом переданным в параметры, так же на вход можно передавать параметры для возвращаемой функции.\ncall и apply  в свою очередь вызывают эту функцию с заданным контекстом так же можно передавать параметры для функции единственное различие что apply на вход принимает массив параметров.\n\n8. Стрелочные функции у нас не имеют контекста следственно не имеют собственного .this это мы можем использовать для того чтобы получать контекст того блока где она вызывается.\nТак же стрелочную функцию нельзя вызвать как конструктор с ключевым словом new. Стрелочная функция не всплывает так же как и функциональное выражение, не имеют объекта arguments. Могут использовать упрощенную форму записи ```func = () = >  code```\n\n9.Что такое замыкание, любая функция является замыканием, когда у нас объявляется функция то у нас захватывается лексическое окружение этой функции и мы не можем получить доступа к полям или методам извне. Только функция может получить доступ к этим полям и между вызовами функции её состояние сохраняется т.к у неё есть лексическое окружение. У функции может быть как и глобальное лексическое окружение так и лексическое окружение блока if for и т.д. где она объявлена и из вне мы не имеем доступа."
    },
    {
      "date": "2024-12-13",
      "content": "```function getMaxSubSum(arr) {\n  let groupSum;\n  let maxSum = 0;\n  for (let groupLenght = 0; groupLenght < arr.length; groupLenght++) {\n    groupSum = 0;\n    for (let second = 0; second < arr.length - groupLenght; second++) {\n      groupSum = getGroupSum(arr, second, second + groupLenght + 1);\n\n      // for (let third = second; third < groupLenght; third++) {\n\n      // }\n\n      if (maxSum < groupSum) {\n        maxSum = groupSum;\n      }\n    }\n  }\n  return maxSum;\n}\nconsole.log(getMaxSubSum([-1, 2, 3, -9]));\nconsole.log(getMaxSubSum([2, -1, 2, 3, -9]));\nconsole.log(getMaxSubSum([-1, 2, 3, -9, 11]));\nconsole.log(getMaxSubSum([-2, -1, 1, 2]));\nconsole.log(getMaxSubSum([100, -9, 2, -3, 5]));\nconsole.log(getMaxSubSum([1, 2, 3]));\nconsole.log(getMaxSubSum([1, -2, 3, 4, -5, 6]));\nconsole.log(getMaxSubSum([-1, -2, -3, -4, -5]));\nconsole.log(getMaxSubSum([5, 1, -2, 3, 4, -1, 2]));\nconsole.log(getMaxSubSum([10, 6, -5, 6]));\nconsole.log(getMaxSubSum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]));\nconsole.log(getMaxSubSum([-1, 2, 3, -9, 4, 5, -1, 2]));\n//Ищем по группам т.е берем группу длинной в 1 попорядку проверяем\n//потом берем группу длинной в 2 проверяем каждую\n//берем группу длинной в 3 проверяем каждую\n//максимальная группа будет равна длине массива\n//\nfunction getGroupSum(arr, index1, index2) {\n  let newArr = arr.slice(index1, index2);\n  let sum = 0;\n  newArr.forEach((element) => {\n    sum += element;\n  });\n  return sum;\n}\n```"
    },
    {
      "date": "2024-12-13",
      "content": "```function delay(ms) {\n  return new Promise(function (resolve) {\n    console.log(1); //обработка промиса\n    setTimeout(resolve, ms);\n  });\n}\n// delay(1000).then((result) => {\n//   console.log(result + \"f\");\n// });\n\nfunction delay2(ms, func) {\n  return new Promise(function (resolve) {\n    setTimeout(\n      function () {\n        console.log(2);\n        resolve(func()); //вызов функции выполнение которой задерживается\n      },\n\n      ms\n    );\n  });\n}\n\ndelay2(1000, () => delay(1000));\n\nasync function fetchData() {\n  try {\n    let response = await fetch(\"https://api.example.com/data\");\n    let data = await response.jsonc;\n    console.log(data);\n  } catch (error) {\n    console.log(error);\n  }\n}\n\nfetchData();\nfunction createCounter() {\n  let count = 0;\n  return {\n    increment() {\n      return count++;\n    },\n    decrement() {\n      return count--;\n    },\n    getValue() {\n      return count;\n    },\n  };\n}\n\n// Пример использования:\nconst counter = createCounter();\ncounter.increment(); // 1\ncounter.increment(); // 2\ncounter.decrement(); // 1\ncounter.getValue(); // 1\nfunction createGreeting(name) {\n  // это объявление функции = создание лексического окружения, в нем у нас есть name(внутри createGreeting)\n\n  return function () {\n    console.log(`Привет, ${name}`); // при вызове функции createGreeting мы возвращаем функцию но ещё НЕ объявляем функцию!\n  };\n}\n\nconst b = function () {\n  // функция b объявлена в глобальном лексичеком окружении а не в лексическом окружении createGreeting\n  console.log(`Привет, ${name}`);\n};\n\nfunction createGreeting2(name) {\n  // так же объявляем функцию и возвращаем функцию b\n  // при возврате функции мы не объявляем её внутри createGreeting2 а возвращаем ссылку на функцию которая объявлена в глобальном\n  //лексичесом окружении\n  return b;\n}\n\nvar name = \"Бла-Бла\"; //задаем name в глобальном лексическом окружении\n\nconst greetIvan = createGreeting(\"Иван\")();\n//() - исполнение функции,\n//const greetIvan = createGreeting('Иван') - объявление функции\n//как результат работы функции мы получаем ссылку на функцию внутри createGreetitng\n//после чего при помощи = мы объявляем её т.е это могло бы выглядит так\n//const greetIvan = function () {\n//     console.log(`Привет, ${name}`);\n// };\n//НО! в таком случае мы объявили функцию в глобальном лексическом окружении а не в лексическом окружении createGreeting\n//И следствие этого что у нас нет доступа к name лексического окружения createGreeting\n\n//Да мы объявляем дочернюю функцию и у неё создается СВОЁ лексическоое окружение и если у него нет name то оно ищет его выше и выше\n//по иерархии\n\nconst greetIvan2 = createGreeting2(\"Иван\")();\n//() - исполнение функции,\n//const greetIvan = createGreeting2('Иван') - объявление функции\n//В данном случае объявление в глобальном лексическом окружении происходит(там где было объявлено b)\n\n//Как послесловие могу сказать что лексическое окружение относится не только к функциям но и к блокам кода таким как if, for\n//блок кода это то что находиться внутри {} можно сказать что объявление блока кода = объявлению функции\n//это важно понимать особенно для for\n\nfunction createGreeting3(name) {\n  // Лексическое окружение создается ЗДЕСЬ\n  // В этот момент \"запоминаются\" все доступные переменные\n  return function () {\n    console.log(`Привет, ${name}!`);\n  };\n}\n\nconst greetIvan3 = createGreeting(\"Иван\");\nconst greetMaria = createGreeting(\"Мария\");\ngreetIvan3();\ngreetMaria();\ngreetIvan3();\n\nlet obj = {\n  names: \"vasya\",\n  withContext(msg = \"default hi!\") {\n    console.log(this.names + \" \" + msg);\n    return this;\n  },\n};\nlet diffrentContext = {\n  names: \"applyContext\",\n};\nobj.withContext();\n\nlet func = obj.withContext;\nfunc();\nfunc.apply(obj);\nfunc.apply(diffrentContext, [\"hello\"]);\nfunc.call(diffrentContext, \"hello\");\nfunction ParentPrototype() {\n  this.sayName = function () {\n    console.log(this.name + \" it`s a prototype methon\");\n  };\n}\nfunction ConstructorPeople(name, age) {\n  this.name = name;\n  this.age = age;\n  this.sayName = function () {\n    console.log(this.name);\n  };\n  prototype = new ParentPrototype();\n}\nConstructorPeople.prototype = new ParentPrototype();\nlet people = new ConstructorPeople(\"vasya\", 18);\npeople.sayName();\nnew ConstructorPeople(\"maria\").sayName();\n\nfunction Clouser() {\n  let saved = 0; // приватное\n  this.saved = saved; //контекст\n  return {\n    increment: () => {\n      saved++;\n      this.saved = saved;\n      console.log(\n        `Saved incremented to: лексическое окружение:${saved} and контекст:${this.saved}`\n      );\n    },\n    getSaved: function () {\n      console.log(saved + \" взяли из лексического окружения\"); // Метод для получения значения saved\n    },\n  };\n}\nlet func = Clouser();\nconst obj2 = {\n  rand: function () {\n    console.log(Math.random());\n  },\n};\nfunc.increment();\nconst obj1 = {\n  func: func,\n  ___proto___: obj2,\n};\nconsole.log(obj1.func);\nconst obj = {\n  logMethod: function () {\n    console.log(this.saved + \" взяли из контекста\");\n  },\n  ___proto___: obj1,\n};\nconsole.log(obj);\nlet prototypedObj = Object.create(obj);\nObject.setPrototypeOf(obj, obj1);\nprototypedObj.func.increment();\nprototypedObj.func.increment();\nprototypedObj.func.increment();\nprototypedObj.func.increment();\nconsole.log(prototypedObj.func.getSaved());\nObject.setPrototypeOf(obj1, obj2);\nconsole.log(prototypedObj);\nprototypedObj.rand();\nfunc.getSaved();\nfunc.increment();\nfunc.getSaved();\nfunc.increment();\nfunc.increment();\nfunc.increment();\nfunc.getSaved();\nfunc.getSaved();\nprototypedObj.logMethod();\nlet funcWithoutContext = prototypedObj.logMethod;\nfuncWithoutContext.bind(func);\nfuncWithoutContext();\nfunc.increment();\nfuncWithoutContext(); //берем из контекста\nfunc.getSaved(); //берем из лексического окружения\nfunc.increment;\nfuncWithoutContext(); //берем из контекста\nfunc.getSaved(); //берем из лексического окружения\n```"
    },
    {
      "date": "2024-12-13",
      "content": "```function aclean(arr) {\n  let set = new Set();\n  let result = [];\n  arr.forEach((e) => {\n    set.add(e.split(\"\").sort().join(\"\").toLowerCase());\n  });\n  //отсортирвал по оригинальности при помощи .add  у set\n  set.forEach((element) => {\n    result.push(\n      arr[\n        arr.findIndex(\n          (e) => element == e.split(\"\").sort().join(\"\").toLowerCase()\n        )\n      ]\n    );\n  });\n\n  return result;\n}\nlet arr1 = [\"nap\", \"teachers\", \"cheaters\", \"PAN\", \"ear\", \"era\", \"hectares\"];\nconsole.log(aclean(arr1)); //```"
    },
    {
      "date": "2024-12-16",
      "content": "При использовании console.dir(aclean) вы не сможете увидеть свойство arguments, так как arguments является специальным объектом, доступным только внутри функции во время её выполнения. Он не является свойством функции, поэтому его нельзя увидеть через console.dir() или другие методы, которые выводят свойства объекта.\nЕсли вы хотите увидеть текущее состояние arguments, вам нужно выводить его непосредственно внутри функции.\n\nЕсли мы выведем объект стрелочной функции то у нас будет свойство arguments, браузер не знает по идее что это за функция и при вызове геттера мы получаем [Исключение: TypeError: 'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them at Function.invokeGetter (<anonymous>:3:28)]\n\nОт себя свойство arguments мы можем использовать ТОЛЬКО внутри самой функции. У стрелочных функций нет arguments. Но мы можем использовать rest параметры (...arg).\n\napply у нас принимает 2 параметра контекст и массив аргументов. При такой передаче у нас в функции доступен только псевдомассив который не имеет методов массива таких как forEach, map. Call у нас принимает несколько параметров(вообще есть ограничение при передаче параметров но это уже к движку), в данном примере работает call и когда мы обращаемся к arr.forEach мы обращаемся к ссылке на передаваемый объект массива, он не является псевдомассивом в отличии если бы мы передали через apply, apply нам бы сформировал новый псевдомассив, а не ссылку на оригинальный массив. \n\nЕсли нам нужно использовать методы массива то мы можем преобразовать псевдомассив в массив при помощи Array.from(arg)\n\n\n\n```function aclean(arr) {\n   console.log(arguments);\n  console.dir(this);\n  console.dir(aclean);\n  console.dir(arguments.callee);\n  console.dir(aclean);\n  console.log(arguments);\n   console.log(Object.getOwnPropertyNames(aclean));\n   console.log(aclean.arguments);\n   console.log(aclean.caller);\n   console.log(aclean.name);\n   console.log(aclean.prototype);\n  let set = new Set();\n  let result = [];\n  console.log(arr);\n  arr.forEach((e) => {\n    set.add(e.split(\"\").sort().join(\"\").toLowerCase());\n  });\n  //отсортирвал по оригинальности при помощи .add  у set\n  set.forEach((element) => {\n    result.push(\n      arr[\n        arr.findIndex(\n          (e) => element == e.split(\"\").sort().join(\"\").toLowerCase()\n        )\n      ]\n    );\n  });\n\n  return result;\n}\nlet arr1 = [\"nap\", \"teachers\", \"cheaters\", \"PAN\", \"ear\", \"era\", \"hectares\"];\n// aclean.apply(arr1, arr1);\naclean(arr1);\n// let result = [...array]\n// array.forEach(element => {\n//     element = toString(element)\n//     values.forEach(value => {\n//         value = toString(value)\n//         if (element === value){\n//             result.splice(result.indexOf(element), 1)\n//         }\n//     })\n// });\n// return result\nlet func1 = (arg) => {\n  console.log(Object.getOwnPropertyNames(func1));\n  console.log(arguments);\n  let i = 0;\n  // console.log(arguments);\n  //Uncaught ReferenceError: arguments is not defined\n};\nfunc1.b = 1;\nfunc1(\"123\");\nconsole.dir(func1);\n```\n"
    },
    {
      "date": "2024-12-16",
      "content": "instanceof Определяет принадлежность данного объекта к классу, функции конструктору и для встроенных классов тоже работает таких как array \n```\nconst arr = [1, 2, 3];\nconsole.log(arr instanceof Array) //true\nconsole.log(arr instanceof Object) // true\n```\n\nПочему так происходит? Потому что instanceof ищет по цепочке наследований прототипов пока не дойдет до null \n```function Animal() {}\nfunction Dog() {}\n\nDog.prototype = Object.create(Animal.prototype); // Устанавливаем наследование\nDog.prototype.constructor = Dog; // Восстанавливаем ссылку на конструктор\n\nconst dog = new Dog();\n\nconsole.log(dog instanceof Dog);      // true\nconsole.log(dog instanceof Animal);   // true\nconsole.log(dog instanceof Object);    // true\nconsole.log(dog instanceof Array);     // false\n```\n\n\ndog является экземпляром Dog, поэтому dog instanceof Dog возвращает true.\n\nDog наследует от Animal, поэтому dog instanceof Animal также возвращает true.\n\nAnimal наследует от Object, поэтому dog instanceof Object возвращает true.\n\ndog не является экземпляром Array, поэтому dog instanceof Array возвращает false."
    },
    {
      "date": "2024-12-16",
      "content": "У движка который мы предположительно используем V8 разработанный google оптимизация и в целом работа реализована так:\n \nУ нас есть ignition и turboFan \nIgnition - Быстрый в плане скорости первого запуска интерпретатор который компилирует js код в неоптимизированный байт код. Этот код может быть выполнен сразу без длительной компиляции.\nКогда у нас код уже был запущен и есть узкие места которые можно оптимизировать в работу вступает turboFan. \nturboFan - Just In time компилятор который оптимизирует уже сгенерированный байткод ignition уже во время его работы. Он работает в фоне и позволяет оптимизировать уже запущенный неоптимизированный код. Что конкретно оптимизирует turboFan? Места которые часто повторяются или же если это сложные операции то он оптимизирует эти места.\nКак он оптимизирует код? Приведу на реальных примерах как я это понял. \n\nКэширование,(похожий механизм у React.memo). Когда у нас не изменяются входные параметры и функция чистая то она не выполняется повторно а берет результат выполнения из кэша. Если же у нас приходят неожиданные результаты выполнения функции то оптимизированный участок у нас возвращается в неоптимизированный(turboFan умеет переключаться между этими состояниями).\n\nJIT компиляция из-за того что turboFan jit компилятор который ответственен за оптимизацию и он может не компилировать и не оптимизировать(что тратит ресурсы) неиспользуемый код. Например когда мы используем React.memo или же чистый компонент. То-есть когда мы используем эти подходы оптимизации то turboFan не задействован.\n\nОптимизация на основе профилирования, V8 собирает информацию о частоте и времени выполнения кода(узкие места) и уже оптимизирует их на уровне байт кода.\n\nИнлайнинг одна из ключевых оптимизаций в движке v8. Как же она работает? Все просто, вместо обращения к функции при использовании оптимизации мы просто вставляем тело функции\n\nОчень простой и понятный пример\n```\n//Без инлайнинга\nfunction add(a, b) {\n    return a + b;\n}\n\nfunction calculate() {\n    let result1 = add(2, 3);\n    let result2 = add(5, 7);\n    return result1 + result2;\n}```\n\n```function calculate() {\n    let result1 = 2 + 3; // Инлан код\n    let result2 = 5 + 7; \n    return result1 + result2;\n}```\n\nДля чего это нужно и как это помогает быстрее выполнять код?\nПри каждом новом вызове функции мы создаем контекст выполнения, передаем аргументы и возвращаем значение, что можно избежать во время JIT компиляции как в примере.\nТак же V8 умеет удалять \"Мёртвый код\" если он видит что функция или переменная не используется в уже инлайн коде. Уменьшение размера кода = лучшая производительность т.к движку не нужно анализировать данный код(что требует ресурсы).\n\nОптимизация типов, вкратце если V8 видит один и тот же тип данных то оптимизирует код для работы с этим типом данных. Что кстати нам дает TypeScript \n\nСборка мусора. Если V8 видит что новые объекты больше не создаются то он не будет выполнять сборку мусора для них.(на что требуются ресурсы)\n"
    },
    {
      "date": "2024-12-17",
      "content": "ТЕСТ"
    },
    {
      "date": "2024-12-17",
      "content": "Свойства объекта имеют кроме value ещё три собственных свойства так называемые дескрипторы обычно они скрыты по умолчанию.\n\nwritable - если true данное свойство можно изменять если false то невозможно изменить.\nenumerable- если true то перечисляется в циклах такие как for, for in, map если false то данное свойство игнорируется при переборе.\nconfigurable - если true свойство можно изменять свойство можно изменять а так же удалять в противном случае этого делать нельзя.\n\n```\nlet descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);\n\nObject.defineProperty(obj, propertyName, descriptor)\n```\nТак мы можем получить дескриптор\nИли же установить его\nПри получении свойств объекта дескрипторы не копируются и чтоб сделать более точную копию объекта нам нужно копировать так же дескрипторы.\n```let clone = Object.defineProperties({}, Object.getOwnPropertyDescriptors(obj));```\n\n\n\n\nГеттеры и Сеттеры\n\nУ объекта мы можем определить геттер и сеттер \n```let obj = {\n  get propName() {\n    // геттер, срабатывает при чтении obj.propName\n  },\n\n  set propName(value) {\n    // сеттер, срабатывает при записи obj.propName = value\n  }\n};\n```\nПри обращении к свойству объекта obj.propName у нас вызывается гетер get propName(). При попытке задать свойство obj.propName = у нас вызывается сеттер set propName().\n\nОчень удобно например сделать обертку обработчик для поля например если мы задаем пустое поле Name можно написать сеттер который не будет устанавливать пустое значение и выдаст нам ошибку а будет устанавливать то что нам нужно.\n\n\nPrototype\n\nМы можем создать объект с указанием прототипа при помощи\n```Object.create(proto[, descriptors])```\n\nМожем устанавливать и получать текущий прототип уже созданного объекта\n```\nObject.getPrototypeOf(obj)\nObject.setPrototypeOf(obj, proto)\n```\n\nТак же у объекта есть свойство prototype и аксессор ___proto___ это как раз таки наши get set для свойства prototype НО! на данный момент такой подход не используется но аксессор у нас присутствует.\n\n\n"
    },
    {
      "date": "2024-12-17",
      "content": "Деструктуризация\nЧаще всего у нас используются две структуры, массивы и объекты . Деструктуризация позволяем нам удобно \"распаковать\" нужные дам данные из массива или объекта.\n\nдля массива \n```\nlet arr = [\"ilya\",\"lenin\"]\nlet [firstName, lastName] = arr\n```\nВ данном случае мы записали значения из массива т.к массив это отсортированная структура которая идет по порядку первый(0) и второй(1) объект массива в переменные firstName и lastName.\nТак же мы можем задать значения по умолчанию если мы их не передаем при деструктуризации.\nИ ещё очень удобный способ записать первые нужные нам объекты массива и вывести все остаточные при помощи оператора ...(троеточие).  Обязательно чтобы все оставшиеся параметры шли после уже заданных.\n\nдля объекта\n```let options = {\n  title: \"Menu\",\n  width: 100,\n  height: 200\n};\n\nlet {title, width, height} = options;\n```\nВ данном случае названия переменных соответствуют ключам в объекте, порядок не имеет значения название переменной соотносится с ключом.\nТак же мы можем задать свои названия переменных\n```let {width: w, height: h, title} = options;```\nТак же можно задать значения по умолчанию если таковых нет у объекта.\nОператор остаточных параметров ...(троеточие) так же работает.\n\n\nФункции\nТак же мы можем применять деструктуризацию для параметров функции, синтаксис такой же как и у деструктуризации объекта, только для параметров функции.\n"
    },
    {
      "date": "2024-12-23",
      "content": "Promise это объект который предоставляющий результат выполнения асинхронной операции у которого есть состояние pending, fulfilled, rejected. Есть методы экземпляра .then резолвит промис, т.е ожидает пока промис решиться в fulfilled .catch аналогично но ждет пока решиться rejected. Так же есть finally он выполнятся вне зависимости от результата промиса fulfilled или rejected. На вход в промис подаются два калбека resolved и rejected которые выполняются в случае успешного/неуспешного выполнения кода внутри promise. \n\n\n```let promise = new Promise(function(resolve, reject) {\n  // эта функция выполнится автоматически, при вызове new Promise\n\n  // через 1 секунду сигнализировать, что задача выполнена с результатом \"done\"\n  setTimeout(() => resolve(\"done\"), 1000);\n});\n```\n\n\nЕсть статические методы класса Promise которые выполняются не в контексте экземпляра. Promise.all() Резолвит все промисы переданные в него если один не выполняется то выдает rejected на все, Promise.any() выполняет все промисы и возвращает тот которые первый вернется в состоянии resolved, Promise.allSelted резолвит все промисы и возвращает массив с результатом выполнения всех промисов при том что порядок в массиве такой же как и при передаче туда промисов очередность выполнения не важна ,Promise.Race резолвит все запросы и возвращает тот который первый резолвнулся не важно какое состояние Fulfilled или rejected, помогает решить проблему с выполнением долгих операций чтобы они не блокировали код. \n\nСинхронный код выполняется по строчно т.е это весь код который не записывается в таски или микротаски а это микротаски - промисы и собственные микротаски .then,асинхронные функции , к таскам относиться события браузера setTimeout (webApi). Все эти задачи выполняются после синхронного кода, т.е когда новых команд не поступает в работу вступает eventLoop.\n\n\nВсе микро таски и таски записываются на верх очереди тасков/микротасков поочередно тоесть самый последний будет на самом верху очереди таски/микротаски. Далее у нас берется первый из очереди микротаски и записывается в stack на этом один loop заканчивается и начинается заново проверяется очередь микротасков и т.д пока очередь микротасков не будет пуста, после этого у нас исполняется render queue тоесть если у нас вся эта очередь микротасок заняла 200 мс то рендера не будет происходить 200 мс и тогда все вызовы отрисовки одним обработаются. После отрисовки у нас выполняется одна задача из тех что я описал выше события браузера, setTimeout (webApi)."
    },
    {
      "date": "2024-12-23",
      "content": "Из .then можно составлять цепочку поочередного выполнения операций. Если .then передает значение то будет передано следующему .then в цепочке. Если .then передает промис то следующий .then будет дожидаться его выполнения. Цепочка может выглядеть так: \n```\nfunction fetchData() {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            resolve(\"Данные загружены\");\n        }, 1000);\n    });\n}\n\nfetchData()\n    .then(result => {\n        console.log(result); // \"Данные загружены\"\n        return \"Следующий шаг\"; // Передаем значение дальше\n    })\n    .then(nextStep => {\n        console.log(nextStep); // \"Следующий шаг\"\n        throw new Error(\"Ошибка на следующем шаге\"); // Выбрасываем ошибку\n    })\n    .catch(error => {\n        console.error(\"Обработано в catch:\", error.message); // \"Обработано в catch: Ошибка на следующем шаге\"\n    })\n    .finally(() => {\n        console.log(\"Завершение цепочки\"); // Выполняется всегда\n    });\n```\nЕсли обработчик выбрасывает исключение в цепочке .then то управление передается ближайшему  .catch. Если в .then возвращается отклонённый промис то управление так же передается ближайшему .catch. При такой передаче если мы перепрыгиваем к .catch то последующие .then не будут выполнены.\n"
    }
  ]
}
