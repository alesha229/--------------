{
  "topics": {
    "intro_js": true,
    "specifications": true,
    "code_editors": true,
    "dev_console": true,
    "variables": true,
    "data_types": true,
    "interaction": true,
    "type_conversions": true,
    "operators": true,
    "comparison": true,
    "ifelse": true,
    "logical_operators": true,
    "nullish": true,
    "loops": true,
    "switch": true,
    "functions": true,
    "function_expressions": true,
    "arrow_functions": true,
    "debugging": true,
    "coding_style": true,
    "comments": true,
    "ninja_code": true,
    "testing": true,
    "polyfills": true,
    "object_basics": true,
    "object_copy": true,
    "garbage_collection": true,
    "object_methods": true,
    "constructor_new": true,
    "optional_chaining": true,
    "symbol": true,
    "object_to_primitive": true,
    "primitives_methods": true,
    "numbers": true,
    "strings": true
  },
  "diary": [
    {
      "date": "2024-12-11",
      "content": "PROTOTYPE\n\nСегодня изучил свойство prototype то есть у каждого объекта есть свой прототип и мы можем использовать методы и значения в родительском прототипе а у этого прототипа может быть выше родитель, и так если мы вызвали какой-то метод и в нашем объекте такого нет то js ищет в прототипе этот метод, если не нашел то в прототипе прототипа и т.д пока не дойдет до null.\n\nCONTEXT .this\nТак же разобрался как работает контекст. Что такое вообще контекст это \"среда\" выполнения функции или методы то есть конкретные методы или же значения которые нам доступны по ссылке .this . Как же с ним работать? Контекст у нас создается при вызове функции/метода того объекта или функции у которой они были вызваны. Но если мы запишем функцию/метод в переменную и вызовем её после то контекст у нас будет потерян. Для решения этой проблемы или задания другого контекста мы можем использовать .bind .apply .call\nих отличия в том что .bind не вызывает функцию но задает контекст и может передавать аргументы, .apply и .call почти одно и тоже они так же задают контекст но исполняют функцию/метод их отличия в том что .apply принимает на вход массив аргументов.\n\nCLASS\nРазобрался и посмотрел принципы ООП конкретно в JS и как их реализовать. Что такое класс, это пользовательский тип который имеет собственные методы и конструктор, классы могут наследоваться для реализации принципов ООП. \n\nЧто такое конструктор класса, это специальный метод который задает и создает новый экземпляр объекта класса при инициализации. То есть что он делает на вход подаются параметры и конструктор уже заполняет поля класса, может использовать для этого методы класса. То есть нужно различать что такое конструктор и что такое поле класса. Поле класса это данные которые мы в нем храним. А конструктор устанавливает значения всем этим полям. (Поле может быть приватным используя префикс # об этом в ниже)\n\n\nИнкапсуляция это принцип когда мы объединяем методы и данные для работы в одном классе для сокрытия реализации, так же к этому относиться #private поля то есть извне класса не можем получить их, только методы внутри класса могут их использовать.\n\nАбстракция это принцип когда мы описываем методы в классе но отдаем её реализацию наследуемым классам то есть у нас есть минимальное описание метода в родителе для понимания что этот метод должен делать \"абстракция\" и наследуемый класс реализует этот метод конкретизируя что этот метод делает.\n\nНаследование это принцип это когда мы создаем новый класс на основе родительского используя методы и данные из родителя.\n\nПолиморфизм это принцип когда мы можем работать с разными типами объектов через общий интерфейс(интерфейс это метод) \n(Не очень разобрался в теме так что прикреплю пример)\n\n```\nclass Animal {\n    makeSound() {\n        return \"Какой-то звук\";\n    }\n}\n\nclass Dog extends Animal {\n    makeSound() {\n        return \"Гав!\";\n    }\n}\n\nclass Cat extends Animal {\n    makeSound() {\n        return \"Мяу!\";\n    }\n}\n\n// Функция работает с любым животным\nfunction animalSound(animal) {\n    console.log(animal.makeSound());\n}\n\nlet dog = new Dog();\nlet cat = new Cat();\n\nanimalSound(dog); // \"Гав!\"\nanimalSound(cat); // \"Мяу!\"\n```\n\nSUPER\nТак же разобрался с ключевым словом super. Super используется для доступа к полям и методам родителя то есть мы указываем что мы используем поля и методы родителя а не дочернего класса. То есть у нас есть два класса родительский и дочерний и у нас есть одинаковые поля/методы в них и при использовании super.say() будет использован метод родительского класса, так же работает и с полями.\n\n\nPromise async await\nПосмотрел и поделал примеры с promise. Что такое promise это объект ожидающий асинхронного выполнения операции. То есть внутри promise мы выполняем асинхронные операции как пример это setTimeout(), Fetch, функции с префиксом async - это означает то что функция выполняется асинхронно. Асинхронность если просто объяснить то это когда выполнение кода не блокируется то есть мы не ждем выполнения команды(строки) относительно синхронного кода. Синхронность это когда мы ждем выполнения команды чтобы выполнить следующую . await это команда ожидания выполнения асинхронной операции т.е он останавливает выполнение функции пока она не выполниться. \n\nТак же затронул темы замыкания, области видимости ликсической области видимости, и всплытие. Но пока резюмировать не могу с точностью."
    },
    {
      "date": "2024-12-12",
      "content": "Что такое замыкания, это функция которая запоминает внешние значения которые могут быть изменены только при помощи специальных методов внутри неё т.е переменная внутри функции при создании лексического окружения \"защищена\" от доступа из вне(чтение/запись).\n\n```У такой функции есть лексическая зона видимости, т.е её значения перекрывают глобальные и из другого лексического окружения её не видно.\nКак задать новое лексическое окружение?\nconst counter1 = createCounter();\nconst counter2 = createCounter()\n\nДанные экземпляры функций создали свое лексическое окружение и не имеют доступ к полям друг друга.\n\nПри повторном вызове экземпляра функции в одном и том же лексическом окружении значения полей сохраняются.\n\nЧто такое лексическое окружение? Это область(scope) переменных, оно создается каждый раз когда выполняется функция или создается блок кода(например в условии или цикле)```\n\nОШИБОЧНОЕ СУЖДЕНИЕ\n\nПопробуем ещё раз объяснить\nЛексическое окружение создается когда мы объявляем функцию.\n\n```function createGreeting(name) {\n    // Лексическое окружение создается ЗДЕСЬ\n    // В этот момент \"запоминаются\" все доступные переменные\n    return function() {\n        console.log(`Привет, ${name}!`);\n    };\n}\n\nconst greetIvan = createGreeting('Иван');\nconst greetMaria = createGreeting('Мария');\n\n// greetIvan и greetMaria - разные экземпляры,\n// но с разными лексическими окружениями```\n\nВот пример \n```const greetIvan = createGreeting('Иван');\nconst greetMaria = createGreeting('Мария');\n```\nВ данном случае это будет правильно работать НО! именно в этом участке происходит объявление функции т.к как результат выполнения функции createGreeting это другая функция\n```    return function() {\n        console.log(`Привет, ${name}!`);\n    };\n```\nМы исполняем и передаем в лексическое окружение createGreeting 'Иван' поле name и дальше эта функция возвращает другую функцию и в объявлении этой функции когда greetIvan = createGreeting  у нас создается лексическое окружение функции которую мы вернули. У неё родитель это createGreeting где есть поле name = 'Иван'. Далее мы ещё раз вызываем и изменяем переменную внутри функции createGreeting name = \"Мария\" и опять возвращаем функцию и там где мы вызывали эту функцию мы её объявляем и у нас создается второе лексическое окружение у которой опять же родитель createGreeting и где name = 'Иван' \n\nТо есть по итогу у каждого из двух полученых лексических окружений новых ссылка на name сохраняется в их лексическое окружение \nВАЖНО!!!\n\nЗначения переменных фиксируются при ВЫЗОВЕ\n\n```// Лексическое окружение greetIvan\n{\n    [[Environment]]: {\n        name: 'Иван',  // Сохраненная ссылка\n        parentContext: GlobalEnvironment\n    }\n}\n\n// Лексическое окружение greetMaria\n{\n    [[Environment]]: {\n        name: 'Мария', // Отдельная сохраненная ссылка\n        parentContext: GlobalEnvironment\n    }\n}\n```\n\nКак я разобрал пример Эда с комментариями\n\n```\nfunction createGreeting(name) {\n  // это объявление функции = создание лексического окружения, в нем у нас есть name(внутри createGreeting)\n\n  return function () {\n    console.log(`Привет, ${name}`);// при вызове функции createGreeting мы возвращаем функцию но ещё НЕ объявляем функцию!\n  };\n}\n\nconst b = function () {\n  // функция b объявлена в глобальном лексичеком окружении а не в лексическом окружении createGreeting\n  console.log(`Привет, ${name}`);\n};\n\nfunction createGreeting2(name) {\n  // так же объявляем функцию и возвращаем функцию b\n  // при возврате функции мы не объявляем её внутри createGreeting2 а возвращаем ссылку на функцию которая объявлена в глобальном\n  //лексичесом окружении\n  return b;\n}\n\nvar name = \"Бла-Бла\"; //задаем name в глобальном лексическом окружении\n\nconst greetIvan = createGreeting(\"Иван\")();\n//() - исполнение функции,\n//const greetIvan = createGreeting('Иван') - объявление функции\n//как результат работы функции мы получаем ссылку на функцию внутри createGreetitng\n//после чего при помощи = мы объявляем её т.е это могло бы выглядит так\n//const greetIvan = function () {\n//     console.log(`Привет, ${name}`);\n// };\n//НО! в таком случае мы объявили функцию в глобальном лексическом окружении а не в лексическом окружении createGreeting\n//И следствие этого что у нас нет доступа к name лексического окружения createGreeting\n\n//Да мы объявляем дочернюю функцию и у неё создается СВОЁ лексическоое окружение и если у него нет name то оно ищет его выше и выше\n//по иерархии \n\nconst greetIvan2 = createGreeting2(\"Иван\")();\n//() - исполнение функции,\n//const greetIvan = createGreeting2('Иван') - объявление функции\n//В данном случае объявление в глобальном лексическом окружении происходит(там где было объявлено b)\n\n\n//Как послесловие могу сказать что лексическое окружение относится не только к функциям но и к блокам кода таким как if, for\n//блок кода это то что находиться внутри {} можно сказать что объявление блока кода = объявлению функции\n//это важно понимать особенно для for\n```"
    },
    {
      "date": "2024-12-12",
      "content": "Краткое резюме по всем вопросам\n1.Типы данных примитивные и передаваемые по ссылке\nПримитивные\nstring\nnumber\nboolean\nnull\nundefiend\nbigInt\nПередаваемые по ссылке\nэто object но в него входят много подтипов\nfunction\narray\ndate\nregExp\nи пр.\n\n2.Оператор typeof у нас возвращает тип передаваемого в него данных ответ приходит строкой\nВ случае проверки null то он возвращает = object это ошибка языка js\n\n3.var let и const это переменные, var устаревший тип записи переменной, т.к он имеет нежелательное свойство то что она имеет глобальную область видимости в то время как let и const блочную, const это переменная которую нельзя изменять. Всплытие переменных это когда мы обращаемся к переменной до их вызова var выдаст undefiend а let и const referenceError: is not initialized Но ссылка будет создана.\n\n4.Функция это блок кода который принимает на вход параметры и возвращает результат работы. Для чего оны нужны и используются? Функцию можно и нужно переиспользовать, чтобы не повторять код, функцию можно вызвать как конструктор которая возвращает объект с полями и методами этой функции, при помощи функций мы можем организовать код то есть разделять ответственность и пр. .\n\n5.Контекст функции у нас определяется во время её вызова, если мы используем функцию как конструктор то контекст будет так же доступен через .this. Контекст по умолчанию у нас берется  из самой функции но мы можем его потерять или же задать другой. Контекст потеряется если мы запишем функцию в переменную и попробуем вызвать её то контекст у нас будет пустой. Мы можем его задать при помощи .bind .apply .call\n\n6.При вызове функции как конструктора с использованием оператора new  она возвращает объект у которого сохраняются все поля и методы функции. Так же у каждого объекта есть прототип, и мы можем задавать цепочку прототипов при помощи .prototype или же setPrototypeOf. Прототип это свойство которое задает связь с прототипами объекта, для чего он нужен, если мы обращаемся к объекту то ему передаются все поля и методы прототипа и так же у прототипа который мы указали может быть свой прототип и так образуется цепочка прототипов, при вызове метода или поля смотрится вся цепочка прототипов пока не дойдет до null на нахождение того или иного поля или метода начиная с изначального объекта.\n\n7.bind метод который возвращает функцию с заданным контекстом переданным в параметры, так же на вход можно передавать параметры для возвращаемой функции.\ncall и apply  в свою очередь вызывают эту функцию с заданным контекстом так же можно передавать параметры для функции единственное различие что apply на вход принимает массив параметров.\n\n8. Стрелочные функции у нас не имеют контекста следственно не имеют собственного .this это мы можем использовать для того чтобы получать контекст того блока где она вызывается.\nТак же стрелочную функцию нельзя вызвать как конструктор с ключевым словом new. Стрелочная функция не всплывает так же как и функциональное выражение, не имеют объекта arguments. Могут использовать упрощенную форму записи ```func = () = >  code```\n\n9.Что такое замыкание, любая функция является замыканием, когда у нас объявляется функция то у нас захватывается лексическое окружение этой функции и мы не можем получить доступа к полям или методам извне. Только функция может получить доступ к этим полям и между вызовами функции её состояние сохраняется т.к у неё есть лексическое окружение. У функции может быть как и глобальное лексическое окружение так и лексическое окружение блока if for и т.д. где она объявлена и из вне мы не имеем доступа."
    }
  ]
}