{
  "topics": {
    "intro_js": true,
    "specifications": true,
    "code_editors": true,
    "dev_console": true,
    "variables": true,
    "data_types": true,
    "interaction": true,
    "type_conversions": true,
    "operators": true,
    "comparison": true,
    "ifelse": true,
    "logical_operators": true,
    "nullish": true,
    "loops": true,
    "switch": true,
    "functions": true,
    "function_expressions": true,
    "arrow_functions": true,
    "debugging": true,
    "coding_style": true,
    "comments": true,
    "ninja_code": true,
    "testing": true,
    "polyfills": true,
    "object_basics": true,
    "object_copy": true,
    "garbage_collection": true,
    "object_methods": true,
    "constructor_new": true,
    "optional_chaining": true,
    "symbol": true,
    "object_to_primitive": true,
    "primitives_methods": true,
    "numbers": true,
    "strings": true
  },
  "diary": [
    {
      "date": "2024-12-11",
      "content": "PROTOTYPE\n\nСегодня изучил свойство prototype то есть у каждого объекта есть свой прототип и мы можем использовать методы и значения в родительском прототипе а у этого прототипа может быть выше родитель, и так если мы вызвали какой-то метод и в нашем объекте такого нет то js ищет в прототипе этот метод, если не нашел то в прототипе прототипа и т.д пока не дойдет до null.\n\nCONTEXT .this\nТак же разобрался как работает контекст. Что такое вообще контекст это \"среда\" выполнения функции или методы то есть конкретные методы или же значения которые нам доступны по ссылке .this . Как же с ним работать? Контекст у нас создается при вызове функции/метода того объекта или функции у которой они были вызваны. Но если мы запишем функцию/метод в переменную и вызовем её после то контекст у нас будет потерян. Для решения этой проблемы или задания другого контекста мы можем использовать .bind .apply .call\nих отличия в том что .bind не вызывает функцию но задает контекст и может передавать аргументы, .apply и .call почти одно и тоже они так же задают контекст но исполняют функцию/метод их отличия в том что .apply принимает на вход массив аргументов.\n\nCLASS\nРазобрался и посмотрел принципы ООП конкретно в JS и как их реализовать. Что такое класс, это пользовательский тип который имеет собственные методы и конструктор, классы могут наследоваться для реализации принципов ООП. \n\nЧто такое конструктор класса, это специальный метод который задает и создает новый экземпляр объекта класса при инициализации. То есть что он делает на вход подаются параметры и конструктор уже заполняет поля класса, может использовать для этого методы класса. То есть нужно различать что такое конструктор и что такое поле класса. Поле класса это данные которые мы в нем храним. А конструктор устанавливает значения всем этим полям. (Поле может быть приватным используя префикс # об этом в ниже)\n\n\nИнкапсуляция это принцип когда мы объединяем методы и данные для работы в одном классе для сокрытия реализации, так же к этому относиться #private поля то есть извне класса не можем получить их, только методы внутри класса могут их использовать.\n\nАбстракция это принцип когда мы описываем методы в классе но отдаем её реализацию наследуемым классам то есть у нас есть минимальное описание метода в родителе для понимания что этот метод должен делать \"абстракция\" и наследуемый класс реализует этот метод конкретизируя что этот метод делает.\n\nНаследование это принцип это когда мы создаем новый класс на основе родительского используя методы и данные из родителя.\n\nПолиморфизм это принцип когда мы можем работать с разными типами объектов через общий интерфейс(интерфейс это метод) \n(Не очень разобрался в теме так что прикреплю пример)\n\n```\nclass Animal {\n    makeSound() {\n        return \"Какой-то звук\";\n    }\n}\n\nclass Dog extends Animal {\n    makeSound() {\n        return \"Гав!\";\n    }\n}\n\nclass Cat extends Animal {\n    makeSound() {\n        return \"Мяу!\";\n    }\n}\n\n// Функция работает с любым животным\nfunction animalSound(animal) {\n    console.log(animal.makeSound());\n}\n\nlet dog = new Dog();\nlet cat = new Cat();\n\nanimalSound(dog); // \"Гав!\"\nanimalSound(cat); // \"Мяу!\"\n```\n\nSUPER\nТак же разобрался с ключевым словом super. Super используется для доступа к полям и методам родителя то есть мы указываем что мы используем поля и методы родителя а не дочернего класса. То есть у нас есть два класса родительский и дочерний и у нас есть одинаковые поля/методы в них и при использовании super.say() будет использован метод родительского класса, так же работает и с полями.\n\n\nPromise async await\nПосмотрел и поделал примеры с promise. Что такое promise это объект ожидающий асинхронного выполнения операции. То есть внутри promise мы выполняем асинхронные операции как пример это setTimeout(), Fetch, функции с префиксом async - это означает то что функция выполняется асинхронно. Асинхронность если просто объяснить то это когда выполнение кода не блокируется то есть мы не ждем выполнения команды(строки) относительно синхронного кода. Синхронность это когда мы ждем выполнения команды чтобы выполнить следующую . await это команда ожидания выполнения асинхронной операции т.е он останавливает выполнение функции пока она не выполниться. \n\nТак же затронул темы замыкания, области видимости ликсической области видимости, и всплытие. Но пока резюмировать не могу с точностью."
    }
  ]
}