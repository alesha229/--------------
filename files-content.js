const filesContent = {
  "test.js": "// function delay(ms) {\r\n//   return new Promise(function (resolve) {\r\n//     console.log(1); //обработка промиса\r\n//     setTimeout(resolve, ms);\r\n//   });\r\n// }\r\n// // delay(1000).then((result) => {\r\n// //   console.log(result + \"f\");\r\n// // });\r\n\r\n// function delay2(ms, func) {\r\n//   return new Promise(function (resolve) {\r\n//     setTimeout(\r\n//       function () {\r\n//         console.log(2);\r\n//         resolve(func()); //вызов функции выполнение которой задерживается\r\n//       },\r\n\r\n//       ms\r\n//     );\r\n//   });\r\n// }\r\n\r\n// delay2(1000, () => delay(1000));\r\n\r\n// async function fetchData() {\r\n//   try {\r\n//     let response = await fetch(\"https://api.example.com/data\");\r\n//     let data = await response.jsonc;\r\n//     console.log(data);\r\n//   } catch (error) {\r\n//     console.log(error);\r\n//   }\r\n// }\r\n\r\n// fetchData();\r\n// function createCounter() {\r\n//   let count = 0;\r\n//   return {\r\n//     increment() {\r\n//       return count++;\r\n//     },\r\n//     decrement() {\r\n//       return count--;\r\n//     },\r\n//     getValue() {\r\n//       return count;\r\n//     },\r\n//   };\r\n// }\r\n\r\n// // Пример использования:\r\n// const counter = createCounter();\r\n// counter.increment(); // 1\r\n// counter.increment(); // 2\r\n// counter.decrement(); // 1\r\n// counter.getValue(); // 1\r\n// function createGreeting(name) {\r\n//   // это объявление функции = создание лексического окружения, в нем у нас есть name(внутри createGreeting)\r\n\r\n//   return function () {\r\n//     console.log(`Привет, ${name}`); // при вызове функции createGreeting мы возвращаем функцию но ещё НЕ объявляем функцию!\r\n//   };\r\n// }\r\n\r\n// const b = function () {\r\n//   // функция b объявлена в глобальном лексичеком окружении а не в лексическом окружении createGreeting\r\n//   console.log(`Привет, ${name}`);\r\n// };\r\n\r\n// function createGreeting2(name) {\r\n//   // так же объявляем функцию и возвращаем функцию b\r\n//   // при возврате функции мы не объявляем её внутри createGreeting2 а возвращаем ссылку на функцию которая объявлена в глобальном\r\n//   //лексичесом окружении\r\n//   return b;\r\n// }\r\n\r\nvar name = \"Бла-Бла\"; //задаем name в глобальном лексическом окружении\r\n\r\nconst greetIvan = createGreeting(\"Иван\")();\r\n//() - исполнение функции,\r\n//const greetIvan = createGreeting('Иван') - объявление функции\r\n//как результат работы функции мы получаем ссылку на функцию внутри createGreetitng\r\n//после чего при помощи = мы объявляем её т.е это могло бы выглядит так\r\n//const greetIvan = function () {\r\n//     console.log(`Привет, ${name}`);\r\n// };\r\n//НО! в таком случае мы объявили функцию в глобальном лексическом окружении а не в лексическом окружении createGreeting\r\n//И следствие этого что у нас нет доступа к name лексического окружения createGreeting\r\n\r\n//Да мы объявляем дочернюю функцию и у неё создается СВОЁ лексическоое окружение и если у него нет name то оно ищет его выше и выше\r\n//по иерархии\r\n\r\nconst greetIvan2 = createGreeting2(\"Иван\")();\r\n//() - исполнение функции,\r\n//const greetIvan = createGreeting2('Иван') - объявление функции\r\n//В данном случае объявление в глобальном лексическом окружении происходит(там где было объявлено b)\r\n\r\n//Как послесловие могу сказать что лексическое окружение относится не только к функциям но и к блокам кода таким как if, for\r\n//блок кода это то что находиться внутри {} можно сказать что объявление блока кода = объявлению функции\r\n//это важно понимать особенно для for\r\n\r\nfunction createGreeting3(name) {\r\n  // Лексическое окружение создается ЗДЕСЬ\r\n  // В этот момент \"запоминаются\" все доступные переменные\r\n  return function () {\r\n    console.log(`Привет, ${name}!`);\r\n  };\r\n}\r\n\r\nconst greetIvan3 = createGreeting(\"Иван\");\r\nconst greetMaria = createGreeting(\"Мария\");\r\ngreetIvan3();\r\ngreetMaria();\r\ngreetIvan3();\r\n\r\n// let obj = {\r\n//   names: \"vasya\",\r\n//   withContext(msg = \"default hi!\") {\r\n//     console.log(this.names + \" \" + msg);\r\n//     return this;\r\n//   },\r\n// };\r\n// let diffrentContext = {\r\n//   names: \"applyContext\",\r\n// };\r\n// obj.withContext();\r\n\r\n// let func = obj.withContext;\r\n// func();\r\n// func.apply(obj);\r\n// func.apply(diffrentContext, [\"hello\"]);\r\n// func.call(diffrentContext, \"hello\");\r\n// function ParentPrototype() {\r\n//   this.sayName = function () {\r\n//     console.log(this.name + \" it`s a prototype methon\");\r\n//   };\r\n// }\r\n// function ConstructorPeople(name, age) {\r\n//   this.name = name;\r\n//   this.age = age;\r\n//   this.sayName = function () {\r\n//     console.log(this.name);\r\n//   };\r\n//   prototype = new ParentPrototype();\r\n// }\r\n// ConstructorPeople.prototype = new ParentPrototype();\r\n// let people = new ConstructorPeople(\"vasya\", 18);\r\n// people.sayName();\r\n// new ConstructorPeople(\"maria\").sayName();\r\n\r\nfunction Clouser() {\r\n  let saved = 0; // приватное\r\n  this.saved = saved; //контекст\r\n  return {\r\n    increment: () => {\r\n      saved++;\r\n      this.saved = saved;\r\n      console.log(\r\n        `Saved incremented to: лексическое окружение:${saved} and контекст:${this.saved}`\r\n      );\r\n    },\r\n    getSaved: function () {\r\n      console.log(saved + \" взяли из лексического окружения\"); // Метод для получения значения saved\r\n    },\r\n  };\r\n}\r\nlet func = Clouser();\r\nconst obj2 = {\r\n  rand: function () {\r\n    console.log(Math.random());\r\n  },\r\n};\r\nfunc.increment();\r\nconst obj1 = {\r\n  func: func,\r\n  ___proto___: obj2,\r\n};\r\nconsole.log(obj1.func);\r\nconst obj = {\r\n  logMethod: function () {\r\n    console.log(this.saved + \" взяли из контекста\");\r\n  },\r\n  ___proto___: obj1,\r\n};\r\nconsole.log(obj);\r\nlet prototypedObj = Object.create(obj);\r\nObject.setPrototypeOf(obj, obj1);\r\nprototypedObj.func.increment();\r\nprototypedObj.func.increment();\r\nprototypedObj.func.increment();\r\nprototypedObj.func.increment();\r\nconsole.log(prototypedObj.func.getSaved());\r\nObject.setPrototypeOf(obj1, obj2);\r\nconsole.log(prototypedObj);\r\nprototypedObj.rand();\r\nfunc.getSaved();\r\nfunc.increment();\r\nfunc.getSaved();\r\nfunc.increment();\r\nfunc.increment();\r\nfunc.increment();\r\nfunc.getSaved();\r\nfunc.getSaved();\r\nprototypedObj.logMethod();\r\nlet funcWithoutContext = prototypedObj.logMethod;\r\nfuncWithoutContext.bind(func);\r\nfuncWithoutContext();\r\nfunc.increment();\r\nfuncWithoutContext(); //берем из контекста\r\nfunc.getSaved(); //берем из лексического окружения\r\nfunc.increment;\r\nfuncWithoutContext(); //берем из контекста\r\nfunc.getSaved(); //берем из лексического окружения\r\n",
  "task1.js": "(function () {\r\n  \"use strict\";\r\n})();\r\n\r\ndocument.addEventListener(\"DOMContentLoaded\", () => {\r\n  const checkboxes = document.querySelectorAll(\r\n    '.topic-item input[type=\"checkbox\"]'\r\n  );\r\n  const progressPercentage = document.querySelector(\".progress-percentage\");\r\n\r\n  // Загрузка данных из progress.json\r\n  async function loadProgress() {\r\n    try {\r\n      const response = await fetch(\"progress.json\");\r\n      const progress = await response.json();\r\n\r\n      // Загрузка отмеченных тем\r\n      if (progress.topics) {\r\n        Object.entries(progress.topics).forEach(([topic, isChecked]) => {\r\n          if (isChecked) {\r\n            localStorage.setItem(topic, \"true\");\r\n          }\r\n        });\r\n      }\r\n\r\n      // Загрузка записей дневника\r\n      if (progress.diary) {\r\n        localStorage.setItem(\"diaryEntries\", JSON.stringify(progress.diary));\r\n      }\r\n\r\n      // Обновляем UI\r\n      updateCheckboxes();\r\n      loadEntries();\r\n      updateProgress();\r\n    } catch (error) {\r\n      console.log(\"Не удалось загрузить progress.json:\", error);\r\n    }\r\n  }\r\n\r\n  // Функция обновления чекбоксов\r\n  function updateCheckboxes() {\r\n    checkboxes.forEach((checkbox) => {\r\n      const topic = checkbox.dataset.topic;\r\n      const isChecked =\r\n        localStorage.getItem(topic) === \"true\" ||\r\n        (typeof COMPLETED_TOPICS !== \"undefined\" && COMPLETED_TOPICS[topic]);\r\n      checkbox.checked = isChecked;\r\n    });\r\n  }\r\n\r\n  // Инициализация чекбоксов\r\n  updateCheckboxes();\r\n\r\n  function updateProgress() {\r\n    const total = checkboxes.length;\r\n    const checked = Array.from(checkboxes).filter((cb) => cb.checked).length;\r\n    const percentage = Math.round((checked / total) * 100);\r\n    progressPercentage.textContent = `${percentage}%`;\r\n  }\r\n\r\n  // Начальный подсчет прогресса\r\n  updateProgress();\r\n\r\n  // Инициализация дневника\r\n  const entryDate = document.getElementById(\"entryDate\");\r\n  const entryContent = document.getElementById(\"entryContent\");\r\n  const saveEntry = document.getElementById(\"saveEntry\");\r\n  const entriesHistory = document.getElementById(\"entriesHistory\");\r\n\r\n  // Установка текущей даты\r\n  entryDate.valueAsDate = new Date();\r\n\r\n  // Загрузка истории записей\r\n  function loadEntries() {\r\n    const entries = JSON.parse(localStorage.getItem(\"diaryEntries\") || \"[]\");\r\n    entriesHistory.innerHTML = entries\r\n      .sort((a, b) => new Date(b.date) - new Date(a.date))\r\n      .map(\r\n        (entry) => `\r\n        <div class=\"history-entry\">\r\n          <div class=\"history-date\">${new Date(\r\n            entry.date\r\n          ).toLocaleDateString()}</div>\r\n          <div class=\"history-content\">${formatContent(entry.content)}</div>\r\n        </div>\r\n      `\r\n      )\r\n      .join(\"\");\r\n\r\n    // Подсветка кода после добавления в DOM\r\n    document.querySelectorAll(\".history-entry pre code\").forEach((block) => {\r\n      hljs.highlightBlock(block);\r\n    });\r\n  }\r\n\r\n  // Функция для форматирования контента с кодом\r\n  function formatContent(content) {\r\n    // Заменяем ```js и ```code на ```javascript для единообразия\r\n    content = content.replace(/```(js|code)/g, \"```javascript\");\r\n\r\n    // Если код не обёрнут в маркеры языка, но находится между ```\r\n    content = content.replace(/```\\s*([\\s\\S]*?)```/g, (_, code) => {\r\n      // Проверяем, не начинается ли уже с javascript\r\n      if (!code.trim().startsWith(\"javascript\")) {\r\n        return `\\`\\`\\`javascript${code}\\`\\`\\``;\r\n      }\r\n      return `\\`\\`\\`${code}\\`\\`\\``;\r\n    });\r\n\r\n    // Обрабатываем все блоки кода\r\n    return content.replace(\r\n      /```javascript([\\s\\S]*?)```/g,\r\n      (_, code) =>\r\n        `<pre><code class=\"language-javascript\">${code.trim()}</code></pre>`\r\n    );\r\n  }\r\n\r\n  // Сохранение новой записи\r\n  saveEntry.addEventListener(\"click\", () => {\r\n    const entries = JSON.parse(localStorage.getItem(\"diaryEntries\") || \"[]\");\r\n    entries.push({\r\n      date: entryDate.value,\r\n      content: entryContent.value,\r\n    });\r\n    localStorage.setItem(\"diaryEntries\", JSON.stringify(entries));\r\n\r\n    // Очистка формы\r\n    entryContent.value = \"\";\r\n    entryDate.valueAsDate = new Date();\r\n\r\n    // Обновление истории\r\n    loadEntries();\r\n  });\r\n\r\n  // Начальная загрузка истории\r\n  loadEntries();\r\n\r\n  // Функция для получения всего прогресса\r\n  function getAllProgress() {\r\n    const progress = {\r\n      topics: Array.from(checkboxes).reduce((acc, cb) => {\r\n        if (cb.checked) {\r\n          acc[cb.dataset.topic] = true;\r\n        }\r\n        return acc;\r\n      }, {}),\r\n      diary: JSON.parse(localStorage.getItem(\"diaryEntries\") || \"[]\"),\r\n    };\r\n    return progress;\r\n  }\r\n\r\n  // Добавляем обработчик для кнопки экспорта\r\n  document.getElementById(\"exportProgress\").addEventListener(\"click\", () => {\r\n    const progress = getAllProgress();\r\n    const dataStr = JSON.stringify(progress, null, 2);\r\n\r\n    // Создаем элемент для скачивания\r\n    const downloadEl = document.createElement(\"a\");\r\n    downloadEl.setAttribute(\r\n      \"href\",\r\n      \"data:text/json;charset=utf-8,\" + encodeURIComponent(dataStr)\r\n    );\r\n    downloadEl.setAttribute(\"download\", \"progress.json\");\r\n\r\n    downloadEl.style.display = \"none\";\r\n    document.body.appendChild(downloadEl);\r\n\r\n    downloadEl.click();\r\n    document.body.removeChild(downloadEl);\r\n  });\r\n\r\n  // Загружаем данные из JSON при старте\r\n  loadProgress();\r\n});\r\n",
  "difference.js": "function difference(array, values) {\n  //Создаем результирующий массив\n  let result = [...array];\n  //Используем не результирующий массив а который нам подали на вход т.к при удалении от туда элементов индексы съедут.\n  array.forEach((element) => {\n    //Приводим текущий элемент в типу string для сравнеия\n    element = toString(element);\n\n    values.forEach((value) => {\n      //Приводим элемент во втором массиве к типу string для сравнения\n      value = toString(value);\n\n      if (element === value) {\n        //Если находит в первом массиве такой же элемент\n        //Вырезаем из результирующего массива элемент\n        //Индекс этого элемента находим при помощи indexOf дублирующемуся элементу\n        result.splice(result.indexOf(element), 1);\n      }\n    });\n  });\n  return result;\n}\n\n//\n//Всё что ниже оригинальный код задачи!!!\n//\n\nfunction check(originalArr, values, expectedArr) {\n  const result = difference(originalArr, values);\n\n  let correct = true;\n  if (\n    result.length != expectedArr.length ||\n    !result.every(\n      (item, index) =>\n        (isNaN(item) && isNaN(expectedArr[index])) ||\n        item === expectedArr[index]\n    )\n  ) {\n    correct = false;\n  }\n\n  console.log(`original array: [${originalArr.join(\", \")}]`);\n  console.log(`values: [${values.join(\", \")}]`);\n  console.log(`expected array: [${expectedArr.join(\", \")}]`);\n  console.log(`result: [${result.join(\", \")}]`);\n  console.log(`correct: ${correct}`);\n  console.log(\"\");\n}\n\nfunction toString(obj) {\n  if (obj === null) {\n    return \"null\";\n  } else if (obj === undefined) {\n    return \"undefined\";\n  } else if (isNaN(obj)) {\n    return \"NaN\";\n  } else if (obj === \"\") {\n    return \"''\";\n  } else if (obj === \" \") {\n    return \"' '\";\n  }\n\n  return obj;\n}\n\nArray.prototype.join = function (separator) {\n  let result = \"\";\n\n  for (item of this.values()) {\n    if (!result) {\n      result += toString(item);\n    } else {\n      result += separator + toString(item);\n    }\n  }\n\n  return result;\n};\n\ncheck(\n  [0, 1, 2, 3, 4, 4, 4, 0, 0, 6, 7, 8, 8, 10, 10],\n  [4, 1, 2, 0],\n  [3, 6, 7, 8, 8, 10, 10]\n);\ncheck([], [], []);\n\ncheck(\n  [null, \"b\", NaN, 0, 1, undefined, 0, \"c\", 1.2, 3.4, \"g\", +0, +0, NaN],\n  [\"b\", 0, 1.2, NaN],\n  [null, 1, undefined, \"c\", 3.4, \"g\"]\n);\ncheck(\n  [null, \"b\", NaN, 0, 1, undefined, 0, \"c\", 1.2, \"g\", +0, +0, NaN],\n  [\"b\", 0, 1.2, undefined],\n  [null, NaN, 1, \"c\", \"g\", NaN]\n);\ncheck(\n  [null, \"b\", NaN, 0, 1, undefined, 0, \"c\", 1.2, \"g\", +0, -0, NaN],\n  [\"b\", 0, 1.2, null],\n  [NaN, 1, undefined, \"c\", \"g\", NaN]\n);\n",
  "isEqual.js": "//Список функций был взят из тестового isEqual, т.к нужно ограничиться конкретными проверками, тут ещё можно много реализовать\r\n//Но реализацией занимался самостоятельно там где постфикс1\r\n//Некоторые из оригинальных функций не были реализованы для сравнения map,set,arraybuffer, т.к их нет в тестовых данных\r\nfunction isEqual(value, other) {\r\n  //Сравнение по ссылке\r\n  if (value === other) return true;\r\n\r\n  //Сравнение boolean с приведенем типа != boolean\r\n  //С разных сторон ожидается тип != boolean\r\n  if (isEqualBoolean1(value, other)) return true;\r\n  if (isEqualBoolean1(other, value)) return true;\r\n\r\n  //Аналогичное сравнение примитивного типа с объектом\r\n  if (isEqualObjectsAndPrimitives1(value, other)) return true;\r\n  if (isEqualObjectsAndPrimitives1(other, value)) return true;\r\n\r\n  //Сравнение undefiend и null\r\n  if (isEqualExeption(other, value)) return true;\r\n\r\n  //Проверка на разные типы т.к разные типы мы обработали остались только одинаковые типы(в теории, если не смотреть шире тестов)\r\n  if (!isEqualTypes1(value, other)) return false;\r\n\r\n  //Сравнение строк\r\n  if (!isEqualStringsValue1(value, other)) return false;\r\n\r\n  //Сравнеие символов\r\n  if (isEqualSymbols1(value, other)) return true;\r\n\r\n  //Сравнение дат\r\n  const datesResult = isEqualDates(value, other);\r\n  if (datesResult !== undefined) return datesResult;\r\n\r\n  //Последним мы сравниваем объекты т.к все остальное мы обработали\r\n  return isEqualObjectsValue1(value, other);\r\n}\r\n\r\nfunction isEqualExeption(value, other) {\r\n  //Очень мозги сделало то что null == undefiend думаю можно было лучше реализовать это в коде\r\n\r\n  //Проверка если оба undefiend т.к typeof в обоих случаях выдаст тип undefiend\r\n  if (typeof value == \"undefined\" && typeof other == \"undefined\") {\r\n    return true;\r\n  }\r\n  //Проверка если оба null\r\n  if (\r\n    value == null &&\r\n    other == null &&\r\n    typeof value !== \"undefined\" &&\r\n    typeof other !== \"undefined\"\r\n  ) {\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction isEqualObjectsAndPrimitives1(value, other) {\r\n  //Сравнение примитивов и типов относящихся к object, Number(0) такая обертка выдаст object\r\n\r\n  //Тут null может попасть под object делаем проверку\r\n  if (\r\n    typeof value == \"object\" &&\r\n    typeof other != \"object\" &&\r\n    value !== null &&\r\n    other !== null\r\n  ) {\r\n    //Сравниваем примитив и обернутый примитив\r\n    if (typeof other != \"boolean\") {\r\n      if (value !== null && value == other.valueOf()) return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction isEqualBoolean1(value, other) {\r\n  //Сравнение и обработка boolean типа с приведенем к строке\r\n  if (typeof value == \"boolean\" && typeof other != \"boolean\") {\r\n    if (value !== null && value.toString() == other.toString()) return true;\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction isEqualTypes1(value, other) {\r\n  //Сравниваем типы т.к обработали разные типы\r\n  return typeof value == typeof other;\r\n}\r\n\r\nfunction isEqualStringsValue1(value, other) {\r\n  //Сравниваем с приведенем к строке\r\n  return toString(value) == toString(other);\r\n}\r\n\r\nfunction isEqualSymbols1(value, other) {\r\n  //Сравниваем символы\r\n  if (typeof value == \"symbol\" && typeof other == \"symbol\") {\r\n    return value.toString() == other.toString() ? true : null;\r\n  }\r\n}\r\n\r\nfunction isEqualDates(value, other) {\r\n  //Сначала проверяем является ли датой. Date это не примитив а объект класса Date и мы проверяем принадлежность к нему\r\n  //Если бы мы вызвали typeof то получили бы object\r\n  if (value instanceof Date && other instanceof Date) {\r\n    //Сравниваем время двух объектов date\r\n    return value.getTime() == other.getTime();\r\n  }\r\n  return undefined;\r\n}\r\n\r\nfunction isEqualObjectsValue1(value, other) {\r\n  if (\r\n    typeof value == \"object\" &&\r\n    typeof other == \"object\" &&\r\n    value !== null &&\r\n    other !== null\r\n  ) {\r\n    if (value.length == other.length) {\r\n      //Объясню почему не сравниваем ключи. Сравниваем два входных объекта\r\n      //Изначально убедившись что длина их одинаковая, этим мы исключаем возможности прохождения проверки\r\n      //Когда один объект идентичен по всем полям но у второго есть ещё поля, если будут ещё поля то длинна будет разной.\r\n      //\r\n      //И дальше сравниваем каждый объект по ключу, если ключ или же значение будет не подходить, то объекты будут не равны.\r\n      //Тоесть условно у первого объекта ключи которого мы подставляем будет ключ которого нет во втором объекте, тогда мы\r\n      //не найдем такого значения у второго объекта и он обработается в isEqualExeption. Если же значения по одинаковым ключам\r\n      //будут разные то мы проверим это в каждом обработчике который у нас есть.\r\n      if (Object.keys(value).every((key) => isEqual(value[key], other[key]))) {\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\n//\r\n//Всё что ниже оригинальный код задачи!!!\r\n//\r\n\r\nfunction localIsEqual(value, other) {\r\n  // Если ссылаются на одно и то же значение, вернуть true\r\n  if (value === other) return true;\r\n\r\n  //Проверка на объект-примитив и наоборот\r\n  if (isEqualObjectsAndPrimitives(value, other)) return true;\r\n  if (isEqualObjectsAndPrimitives(other, value)) return true;\r\n\r\n  // Если разный тип, вернуть false\r\n  if (!isEqualTypes(value, other)) return false;\r\n\r\n  // Проверяем строковые значения (Эта проверка нужна для примитивов!)\r\n  if (!isEqualStringsValue(value, other)) return false;\r\n\r\n  if (isEqualSymbols(value, other)) return false;\r\n\r\n  if (!isEqualTypedArrays(value, other)) return false;\r\n\r\n  if (isEqualMaps(value, other)) {\r\n    let [arrValue, arrOther] = GetValueMaps(value, other);\r\n    return localIsEqual(arrValue, arrOther);\r\n  }\r\n\r\n  if (isEqualSets(value, other)) {\r\n    let [arrValue, arrOther] = GetValueSets(value, other);\r\n    return localIsEqual(arrValue, arrOther);\r\n  }\r\n\r\n  // Проверяем значение ключей\r\n  return isEqualObjectsKeys(value, other);\r\n}\r\n\r\nfunction isEqualObjectsAndPrimitives(object, primitive) {\r\n  if (typeof object == \"object\" && typeof primitive != \"object\") {\r\n    if (object !== null && primitive === object.valueOf()) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction isEqualTypes(value, other) {\r\n  if (typeof value != typeof other) {\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\n\r\nfunction isEqualStringsValue(value, other) {\r\n  if (value.toString() != other.toString()) {\r\n    return false;\r\n  }\r\n  return true;\r\n}\r\n\r\nfunction isEqualSymbols(symbolValue, symbolOther) {\r\n  return isEqualTypesAndSizeObjects(\r\n    \"[object Symbol]\",\r\n    symbolValue,\r\n    symbolOther\r\n  );\r\n}\r\n\r\nfunction isEqualTypedArrays(arrValue, arrOther) {\r\n  if (ArrayBuffer.isView(arrValue) && ArrayBuffer.isView(arrOther)) {\r\n    if (\r\n      arrValue.length != arrOther.length ||\r\n      arrValue.byteLength != arrOther.byteLength\r\n    ) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nfunction isEqualMaps(mapValue, mapOther) {\r\n  return isEqualTypesAndSizeObjects(\"[object Map]\", mapValue, mapOther);\r\n}\r\n\r\nfunction GetValueMaps(mapValue, mapOther) {\r\n  let arrValue = Array.from(mapValue.entries());\r\n  let arrOther = Array.from(mapOther.entries());\r\n  return [arrValue, arrOther];\r\n}\r\n\r\nfunction isEqualSets(setValue, setOther) {\r\n  return isEqualTypesAndSizeObjects(\"[object Set]\", setValue, setOther);\r\n}\r\n\r\nfunction GetValueSets(setValue, setOther) {\r\n  let arrValue = Array.from(setValue);\r\n  let arrOther = Array.from(setOther);\r\n  return [arrValue, arrOther];\r\n}\r\n\r\nfunction isEqualTypesAndSizeObjects(typeObject, value, other) {\r\n  let objectSet = Object.prototype.toString.call(value);\r\n  if (objectSet == typeObject && value.size == other.size) {\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction isEqualObjectsKeys(objValue, objOther) {\r\n  // Получаем массив ключей объктов\r\n  let valueKeys = Object.keys(objValue);\r\n  let otherKeys = Object.keys(objOther);\r\n\r\n  // Если разное количество ключей, вернуть false\r\n  if (valueKeys.length != otherKeys.length) {\r\n    return false;\r\n  }\r\n  // Проверяем, что у них одинаковые ключи\r\n  if (!valueKeys.every((key) => objOther.hasOwnProperty(key))) {\r\n    return false;\r\n  }\r\n  return valueKeys.every((key) => localIsEqual(objValue[key], objOther[key]));\r\n}\r\n\r\nfunction check(value, other) {\r\n  const result = isEqual(value, other);\r\n  const localResult = localIsEqual(value, other);\r\n\r\n  console.log(`left value: ${JSON.stringify(value)}`);\r\n  console.log(`right value: ${JSON.stringify(other)}`);\r\n  console.log(`expected result: ${localResult}`);\r\n  console.log(`correct: ${result === localResult}`);\r\n  console.log(\"\");\r\n}\r\n\r\ncheck(0, new Number(0));\r\ncheck(\"str\", new String(\"str\"));\r\ncheck(true, new Boolean(true));\r\ncheck(true, new Number(1));\r\ncheck(true, new String(\"1\"));\r\ncheck(new Number(1), new String(\"1\"));\r\ncheck(new String(\"str\"), new String(\"str\"));\r\ncheck(NaN, NaN);\r\ncheck(NaN, null);\r\ncheck(NaN, undefined);\r\ncheck(null, undefined);\r\ncheck(true, false);\r\ncheck(true, true);\r\ncheck(+0, -0);\r\ncheck(\"\", null);\r\ncheck({}, {});\r\ncheck([], []);\r\ncheck(\r\n  {\r\n    a: 1,\r\n    b: 2,\r\n    c: {\r\n      a: \"1\",\r\n      b: true,\r\n      c: {\r\n        a: 1,\r\n        b: 2,\r\n        sayHi() {\r\n          return 5;\r\n        },\r\n      },\r\n    },\r\n  },\r\n  {\r\n    a: 1,\r\n    b: 2,\r\n    c: {\r\n      a: \"1\",\r\n      b: true,\r\n      c: {\r\n        a: 1,\r\n        b: 2,\r\n        sayHi() {\r\n          return 4;\r\n        },\r\n      },\r\n    },\r\n  }\r\n);\r\ncheck(\r\n  { a: 1, b: 2, c: { a: \"1\", b: true, c: { a: 1, b: 2 } } },\r\n  { a: 1, b: 2, c: { a: \"1\", b: true, c: { a: 1, b: 2 } } }\r\n);\r\ncheck(\r\n  [\r\n    {\r\n      artist: \"Billy Joel\",\r\n      title: \"Piano Man\",\r\n      release_year: 1973,\r\n      formats: [\"CS\", \"8T\", \"LP\"],\r\n      gold: true,\r\n    },\r\n    1,\r\n    [3, 2],\r\n    [3, [4]],\r\n  ],\r\n  [\r\n    {\r\n      artist: \"Billy Joel\",\r\n      title: \"Piano Man\",\r\n      release_year: 1973,\r\n      formats: [\"C1\", \"8T\", \"LP\"],\r\n      gold: true,\r\n    },\r\n    1,\r\n    [3, 2],\r\n    [3, [4]],\r\n  ]\r\n);\r\ncheck(\r\n  [\r\n    {\r\n      artist: \"Billy Joel\",\r\n      title: \"Piano Man\",\r\n      release_year: 1973,\r\n      formats: [\"CS\", \"8T\", \"LP\"],\r\n      gold: true,\r\n    },\r\n    1,\r\n    [3, 1],\r\n    [3, [4]],\r\n  ],\r\n  [\r\n    {\r\n      artist: \"Billy Joel\",\r\n      title: \"Piano Man\",\r\n      release_year: 1973,\r\n      formats: [\"CS\", \"8T\", \"LP\"],\r\n      gold: true,\r\n    },\r\n    1,\r\n    [3, 1],\r\n    [3, [4]],\r\n  ]\r\n);\r\ncheck(new Date(\"December 17, 1995 03:24:01\"), new Date(\"1995-12-17T03:24:00\"));\r\ncheck(new Date(\"December 17, 1995 03:24:00\"), new Date(\"1995-12-17T03:24:00\"));\r\n",
  "isEqual1.js": "function isEqual(value, other) {\n    throw new Error('Not implemented!');\n}\n\nfunction localIsEqual(value, other) {\n    // Если ссылаются на одно и то же значение, вернуть true\n    if (value === other) return true;\n\n    //Проверка на объект-примитив и наоборот    \n    if (isEqualObjectsAndPrimitives(value, other)) return true;\n    if (isEqualObjectsAndPrimitives(other, value)) return true;\n\n    // Если разный тип, вернуть false \n    if (!isEqualTypes(value, other)) return false;\n\n    // Проверяем строковые значения (Эта проверка нужна для примитивов!)\n    if (!isEqualStringsValue(value, other)) return false;\n\n    if (isEqualSymbols(value, other)) return false;\n\n    if (!isEqualTypedArrays(value, other)) return false;\n\n    if (isEqualMaps(value, other)) {\n        let [arrValue, arrOther] = GetValueMaps(value, other);\n        return localIsEqual(arrValue, arrOther);\n    }\n\n    if (isEqualSets(value, other)) {\n        let [arrValue, arrOther] = GetValueSets(value, other);\n        return localIsEqual(arrValue, arrOther);\n    }\n\n    // Проверяем значение ключей\n    return isEqualObjectsKeys(value, other);\n\n}\n\nfunction isEqualObjectsAndPrimitives(object, primitive) {\n    if (typeof (object) == 'object' && typeof (primitive) != 'object') {\n        if (object !== null && primitive === object.valueOf()) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction isEqualTypes(value, other) {\n    if (typeof value != typeof other) {\n        return false\n    };\n    return true;\n}\n\nfunction isEqualStringsValue(value, other) {\n    if (value.toString() != other.toString()) {\n        return false;\n    }\n    return true;\n}\n\nfunction isEqualSymbols(symbolValue, symbolOther) {\n    return isEqualTypesAndSizeObjects('[object Symbol]', symbolValue, symbolOther);\n}\n\nfunction isEqualTypedArrays(arrValue, arrOther) {\n    if (ArrayBuffer.isView(arrValue) && ArrayBuffer.isView(arrOther)) {\n        if (arrValue.length != arrOther.length || arrValue.byteLength != arrOther.byteLength) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction isEqualMaps(mapValue, mapOther) {\n    return isEqualTypesAndSizeObjects('[object Map]', mapValue, mapOther);\n}\n\nfunction GetValueMaps(mapValue, mapOther) {\n    let arrValue = Array.from(mapValue.entries());\n    let arrOther = Array.from(mapOther.entries());\n    return [arrValue, arrOther];\n}\n\nfunction isEqualSets(setValue, setOther) {\n    return isEqualTypesAndSizeObjects('[object Set]', setValue, setOther);\n}\n\nfunction GetValueSets(setValue, setOther) {\n    let arrValue = Array.from(setValue);\n    let arrOther = Array.from(setOther);\n    return [arrValue, arrOther];\n}\n\nfunction isEqualTypesAndSizeObjects(typeObject, value, other) {\n    let objectSet = Object.prototype.toString.call(value);\n    if (objectSet == typeObject && value.size == other.size) {\n        return true;\n    }\n    return false;\n}\n\nfunction isEqualObjectsKeys(objValue, objOther) {\n    // Получаем массив ключей объктов\n    let valueKeys = Object.keys(objValue);\n    let otherKeys = Object.keys(objOther);\n\n    // Если разное количество ключей, вернуть false\n    if (valueKeys.length != otherKeys.length) {\n        return false;\n    }\n    // Проверяем, что у них одинаковые ключи\n    if (!valueKeys.every((key) => objOther.hasOwnProperty(key))) {\n        return false;\n    }\n    return valueKeys.every((key) => localIsEqual(objValue[key], objOther[key]));\n}\n\nfunction check(value, other) {\n    const result = isEqual(value, other);\n    const localResult = localIsEqual(value, other);\n\n    console.log(`left value: ${JSON.stringify(value)}`);\n    console.log(`right value: ${JSON.stringify(other)}`);\n    console.log(`expected result: ${localResult}`);\n    console.log(`correct: ${result === localResult}`);\n    console.log('');\n}\n\ncheck(0, new Number(0));\ncheck('str', new String('str'));\ncheck(true, new Boolean(true));\ncheck(true, new Number(1));\ncheck(true, new String(\"1\"));\ncheck(new Number(1), new String(\"1\"));\ncheck(new String('str'), new String('str'));\ncheck(NaN, NaN);\ncheck(NaN, null);\ncheck(NaN, undefined);\ncheck(null, undefined);\ncheck(true, false);\ncheck(true, true);\ncheck(+0, -0);\ncheck(\"\", null);\ncheck({}, {});\ncheck([], []);\ncheck(\n    { a: 1, b: 2, c: { a: \"1\", b: true, c: { a: 1, b: 2, sayHi() { return 5; } } } }, \n    { a: 1, b: 2, c: { a: \"1\", b: true, c: { a: 1, b: 2, sayHi() { return 4; } } } }\n);\ncheck(\n    { a: 1, b: 2, c: { a: \"1\", b: true, c: { a: 1, b: 2 } } },\n    { a: 1, b: 2, c: { a: \"1\", b: true, c: { a: 1, b: 2 } } }\n);\ncheck(\n    [\n        {\n          \"artist\": \"Billy Joel\",\n          \"title\": \"Piano Man\",\n          \"release_year\": 1973,\n          \"formats\": [\n            \"CS\",\n            \"8T\",\n            \"LP\"],\n          \"gold\": true\n        },\n        1,\n        [3, 2],\n        [3, [4]],\n    ],\n    [\n        {\n            \"artist\": \"Billy Joel\",\n            \"title\": \"Piano Man\",\n            \"release_year\": 1973,\n            \"formats\": [\n            \"C1\",\n            \"8T\",\n            \"LP\"],\n            \"gold\": true\n        },\n        1,\n        [3, 2],\n        [3, [4]],\n    ]\n);\ncheck(\n    [\n        {\n          \"artist\": \"Billy Joel\",\n          \"title\": \"Piano Man\",\n          \"release_year\": 1973,\n          \"formats\": [\n            \"CS\",\n            \"8T\",\n            \"LP\"],\n          \"gold\": true\n        },\n        1,\n        [3, 1],\n        [3, [4]],\n    ],\n    [\n        {\n          \"artist\": \"Billy Joel\",\n          \"title\": \"Piano Man\",\n          \"release_year\": 1973,\n          \"formats\": [\n            \"CS\",\n            \"8T\",\n            \"LP\"],\n          \"gold\": true\n        },\n        1,\n        [3, 1],\n        [3, [4]],\n    ]\n);\ncheck(new Date('December 17, 1995 03:24:01'), new Date('1995-12-17T03:24:00'));\ncheck(new Date('December 17, 1995 03:24:00'), new Date('1995-12-17T03:24:00'));",
  "proto.js": "// const calculator = {\r\n//     value: 0,\r\n//     add(n){\r\n//         this.value += n\r\n//         return this\r\n//     },\r\n//     subtract(n){\r\n//         this.value /= n\r\n//         return this\r\n//     },\r\n//     multiply(n){\r\n//         this.value *= n\r\n//         return this\r\n//     }\r\n\r\n// }\r\n// calculator.add(10).multiply(10).subtract(10)\r\n// console.log(calculator.value)\r\n\r\n// function Animal(name){\r\n//     this.name = name\r\n//     this.speak = function(){\r\n//         console.log(`Animal ${this.name} makes a sound`\r\n//         )\r\n//     }\r\n//     this.eat = function(){\r\n//         console.log(`${this.name} is eating`)\r\n//     }\r\n\r\n// }\r\n\r\n// function Dog(name, breed){\r\n// Animal.apply(this, arguments)\r\n// this.name = name\r\n// this.breed = breed\r\n// this.speak = this.speak = function(){\r\n//     console.log(`Animal ${this.name} makes a woof`\r\n//     )\r\n// }\r\n// }\r\n// let dog = new Dog('chuppy', 'buldog')\r\n\r\n//  console.log(dog)\r\n\r\n\r\n\r\n// function Vehicle(brand){\r\n//     this.brand = brand\r\n// }\r\n// function Car(brand, model){\r\n// Vehicle.apply(this, arguments)\r\n     \r\n// this.model = model\r\n// }\r\n// function ElectricCar(brand, model, batteryLife){\r\n// Car.apply(this, arguments)\r\n\r\n// this.batteryLife = batteryLife\r\n// }\r\n\r\n// let ElecCar = new ElectricCar('Honda', 'accorde','500km')\r\n// console.log(ElecCar)\r\n\r\n\r\n\r\n\r\n// const user = {\r\n//     name: \"John\",\r\n//     greetings:[],\r\n//     greet(greeting){\r\n//         this.greetings.push(greeting + \", \"+ this.name)\r\n//     },\r\n//     getAllGreetings(){\r\n//         return console.log(this.greetings)\r\n//     }\r\n// }\r\n\r\n\r\n\r\n// setTimeout(()=>user.greet('hi'), 1000)\r\n\r\n// user.getAllGreetings()\r\n\r\n// console.log(user)\r\n\r\n\r\n\r\n// function BankAccount(initialBalance){\r\n// this._balance = initialBalance\r\n\r\n    \r\n// this.deposit = function(amount){\r\n//     this._balance += amount    \r\n// }\r\n\r\n// this.withdraw = function(amount){\r\n//     this._balance -= amount\r\n// }\r\n// this.getBalance = function(){\r\n//     return this._balance\r\n// }\r\n\r\n// }\r\n\r\n\r\n// let userAcc = new BankAccount(10000)\r\n// userAcc._balance = 0\r\n// console.log(userAcc)\r\n\r\n\r\n// let people = {\r\n//     name :'vasya'\r\n// }\r\n// let message = {\r\n//     message:\"heeelp\",\r\n//     sayHi(){\r\n//         console.log('hi '+this.name)\r\n//     }\r\n// }\r\n\r\n// function log(){\r\n//     console.log(this.message)\r\n// }\r\n// let logWithNewContext = log.bind(message)\r\n// logWithNewContext()\r\n\r\n// let sayHiWithNewContext = message.sayHi.bind(people)\r\n\r\n// sayHiWithNewContext()\r\n\r\n\r\n// let user = {\r\n//     firstName:'Вася',\r\n//     say(phrase){\r\n//         console.log(`${phrase}, ${this.firstName} !`)\r\n//     }\r\n// }\r\n\r\n// let say = user.say.bind(user)\r\n\r\n// say(\"привет\")\r\n// say(\"пока\")\r\n\r\n// function mul(a,b){\r\n//     return a * b\r\n// }\r\n\r\n// let double = mul.bind(null,2)\r\n// console.log(double(3))\r\n// console.log(double(2))\r\n\r\n\r\n// function f(){\r\n//     console.log(this)\r\n// }\r\n\r\n// let user = {\r\n//     g: f.bind(null)\r\n// }\r\n\r\n// user.g()\r\n\r\n\r\n// Контекст связанной функции жёстко фиксирован. Изменить однажды привязанный \r\n// контекст уже нельзя.\r\n\r\n// Так что хоть мы и вызываем user.g(), внутри исходная функция будет вызвана \r\n// с this=null. Однако, функции g совершенно без разницы, какой this она получила. \r\n// Её единственное предназначение – это передать вызов в f вместе с аргументами и ранее \r\n// указанным контекстом null, что она и делает.\r\n\r\n// Таким образом, когда мы запускаем user.g(), исходная функция вызывается с this=null.\r\n\r\n// function f(){\r\n//     console.log(this.name)\r\n// }\r\n\r\n// f = f.bind({name:'Вася'}).bind({name:'Валя'})\r\n// f()\r\n\r\n\r\n// Экзотический объект bound function, возвращаемый при первом вызове f.bind(...), \r\n// запоминает контекст (и аргументы, если они были переданы) только во время создания.\r\n\r\n// Следующий вызов bind будет устанавливать контекст уже для этого объекта.\r\n//  Это ни на что не повлияет.\r\n\r\n// Можно сделать новую привязку, но нельзя изменить существующую\r\n\r\n\r\n// function askPassword(ok, fail){\r\n//     let password = prompt(\"Password?\", '')\r\n//     if(password == \"rockstart\") ok()\r\n//         else fail()\r\n// }\r\n\r\n\r\n// let user = {\r\n//     name:'Вася',\r\n\r\n//     loginOk(){\r\n//         console.log(this.name + 'logged')\r\n//     },\r\n//     loginFail(){\r\n//         console.log(this.name + \"logged out\")\r\n//     },\r\n// }\r\n\r\n\r\n\r\n// askPassword(user.loginOk.bind(user), user.loginFail.bind(user))\r\n\r\n\r\nfunction askPassword(ok, fail){\r\n    let password = prompt(\"Password?\", '')\r\n    if(password == \"rockstart\") ok()\r\n        else fail()\r\n}\r\n\r\n\r\nlet user = {\r\n    name:'Вася',\r\n\r\n   login(result){\r\n    console.log(this.name + (result ? 'logged in': 'failed to log in'))\r\n   }\r\n}\r\n\r\n\r\n\r\naskPassword(user.login.bind(user,true), user.login.bind(user,false))\r\n\r\n\r\n\r\n// const timer = {\r\n//     seconds: 0,\r\n//     interval: null,\r\n    \r\n//     start() {\r\n//         // this.interval = setInterval(() => {\r\n//         //     this.seconds++\r\n//         //     console.log(this.seconds)\r\n//         // }, 1000)\r\n\r\n//         this.interval =  setInterval(function (){\r\n//             this.second++\r\n//             console.log(this.seconds)\r\n//         },1000)\r\n//     },\r\n    \r\n//     stop() {\r\n//         clearInterval(this.interval)\r\n//     }\r\n// }\r\n\r\n// timer.start()",
  "sortedUniq.js": "function sortedUniq(array) {\r\n  array.map((element, index) => {\r\n    //На каждый элемент у нас идет цикл while\r\n    //до того момента как у нас не останется дубликатов этого элемента в массиве не считая и не удаляя текущий т.к мы должы\r\n    //удалить дубликаты текущего элемента а не удалить его самого.\r\n    while (array.includes(element, index + 1)) {\r\n      //вырезаем элемент\r\n      array.splice(\r\n        //..С индексом где нашли дубликат, поиск ведем с конца\r\n        //Если бы искали с начала то вся эта система навернулась из-за сдвига индексов в массиве.\r\n        //А при таком подходе у нас просто ищется дубликат текущего элемента и удаляется с конца.\r\n        //Т.к мы проверяем для каждого по порядку элемента дубликаты у нас не может возникнуть\r\n        //такой ситуации когда дубликат находится слева от элемента.\r\n        //При таком подходе сохраняется сортировка массива т.е остается только первый экземпляр(по списку индексов)\r\n        //если он имеет дубликаты. Что прописано и понятно из названии функции что у нас отсортированый уникальны массив возвращает.\r\n        array.findLastIndex(\r\n          (e) =>\r\n            e === element ||\r\n            !(e !== element) ||\r\n            //Здесь у нас обработчик всех неожиданых типов и строк которые могут неправильно работать с нашей функцией.\r\n            exeptionTypesHandler(e) === exeptionTypesHandler(element)\r\n        ),\r\n        1\r\n      );\r\n    }\r\n  });\r\n  return array;\r\n}\r\n\r\n//Обработчик неожиданых строк и типов\r\nfunction exeptionTypesHandler(a) {\r\n  if (!a) {\r\n    if (typeof a === \"undefined\") {\r\n      return String(\"undefiend\");\r\n    } else if (a === null) {\r\n      return String(\"null\");\r\n    } else if (a === 0) {\r\n      return Number(\"0\");\r\n    } else if (a === 1) {\r\n      return Number(\"1\");\r\n    } else if (a === \"\") {\r\n      return String(\"\");\r\n    } else if (a === \" \") {\r\n      return String(\" \");\r\n    } else if (a === NaN) {\r\n      return String(\"NaN\");\r\n    }\r\n  } else {\r\n    return a;\r\n  }\r\n}\r\n\r\n//\r\n//Всё что ниже оригинальный код задачи!!!\r\n//\r\n\r\nfunction check(originalArr, expectedArr) {\r\n  const result = sortedUniq(originalArr);\r\n\r\n  let correct = true;\r\n  if (\r\n    result.length != expectedArr.length ||\r\n    !result.every(\r\n      (item, index) =>\r\n        (isNaN(item) && isNaN(expectedArr[index])) ||\r\n        item === expectedArr[index]\r\n    )\r\n  ) {\r\n    correct = false;\r\n  }\r\n\r\n  console.log(`original array: [${originalArr.join(\", \")}]`);\r\n  console.log(`expected array: [${expectedArr.join(\", \")}]`);\r\n  console.log(`result: [${result.join(\", \")}]`);\r\n  console.log(`correct: ${correct}`);\r\n  console.log(\"\");\r\n}\r\n\r\nfunction toString(obj) {\r\n  if (obj === null) {\r\n    return \"null\";\r\n  } else if (obj === undefined) {\r\n    return \"undefined\";\r\n  } else if (isNaN(obj)) {\r\n    return \"NaN\";\r\n  } else if (obj === \"\") {\r\n    return \"''\";\r\n  } else if (obj === \" \") {\r\n    return \"' '\";\r\n  }\r\n\r\n  return obj;\r\n}\r\n\r\nArray.prototype.join = function (separator) {\r\n  let result = \"\";\r\n\r\n  for (item of this.values()) {\r\n    if (!result) {\r\n      result += toString(item);\r\n    } else {\r\n      result += separator + toString(item);\r\n    }\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\ncheck([1, 2, 2, 3, 4, 4, 5, 5, 6, 6, 6], [1, 2, 3, 4, 5, 6]);\r\ncheck(\r\n  [\r\n    null,\r\n    null,\r\n    undefined,\r\n    undefined,\r\n    NaN,\r\n    NaN,\r\n    NaN,\r\n    1,\r\n    1,\r\n    \"\",\r\n    \"\",\r\n    0,\r\n    0,\r\n    \" \",\r\n    \" \",\r\n  ],\r\n  [null, undefined, NaN, 1, \"\", 0, \" \"]\r\n);\r\ncheck([1, 2, 2], [1, 2]);\r\n",
  "sortedUniq1.js": "let array = [\r\n  \"chemistry\",\r\n  \"computer\",\r\n  \"computer\",\r\n  \"english\",\r\n  \"geography\",\r\n  \"hindi\",\r\n  \"hindi\",\r\n  \"geography\",\r\n  \"maths\",\r\n  \"physics\",\r\n  \"a\",\r\n  \"physics\",\r\n  \"physics\",\r\n  \"a\",\r\n  \"physics\",\r\n  \"physics\",\r\n  \"a\",\r\n  \"physics\",\r\n  \"physics\",\r\n  ,\r\n];\r\n\r\n// array.splice(8, 1);\r\n// console.log(array);\r\n// function sortedUniq(array) {\r\n//   for (i in array) {\r\n//     let isFirst = false;\r\n//     for (b in array) {\r\n//       if (array[i] == array[b]) {\r\n//         if (isFirst) {\r\n//           array.splice(b, 1);\r\n//         }\r\n//         isFirst = true;\r\n//       }\r\n//     }\r\n//     console.log(array);\r\n//     isFirst = false;\r\n//   }\r\n//   return array;\r\n// }\r\n\r\n// function sortedUniq(array) {\r\n//   let unicArray = [];\r\n//   array.map((element, index) => {\r\n//     if (!array.includes(element, index + 1)) {\r\n//       unicArray.push(element);\r\n//     }\r\n//   });\r\n//   return unicArray;\r\n// }\r\n\r\nfunction sortedUniq(array) {\r\n  array.map((element, index) => {\r\n    // if (array.includes(element, index + 1)) {\r\n    //   unicArray.push(element);\r\n    // }else{\r\n    //   unicArray.push(element);\r\n    // }\r\n    while (array.includes(element, index + 1)) {\r\n      array.splice(\r\n        array.findLastIndex((e) => e == element),\r\n        1\r\n      );\r\n    }\r\n  });\r\n  return array;\r\n}\r\n\r\nconsole.log(sortedUniq(array));\r\n",
  "task3.js": "let answer1 = prompt(\"какое официальное название использует javascipt\");\r\nif (answer1 == \"ECMAScript\") {\r\n  alert(\"правильно\");\r\n} else {\r\n  alert(\"Не знаете? ECMAScript!\");\r\n}\r\n//\r\n//----------------------------------------------------------------------\r\n//\r\n\r\n//\r\n//----------------------------------------------------------------------\r\n//\r\nlet promtAnswer = promt(\"Введите любое число\");\r\nif (promtAnswer > 0) {\r\n  alert(\"1\");\r\n} else if (promtAnswer < 0) {\r\n  alert(\"-1\");\r\n} else {\r\n  alert(\"0\");\r\n}\r\n//\r\n//ok\r\n//\r\n\r\n//\r\n//----------------------------------------------------------------------\r\n//\r\nlet result;\r\nif (a + b < 4) {\r\n  result = \"Мало\";\r\n} else {\r\n  result = \"Много\";\r\n}\r\n\r\n//|\r\n//v\r\n\r\nresult = a + b < 4 ? \"Много\" : \"Мало\";\r\n//\r\n//----------------------------------------------------------------------\r\n//\r\n\r\n//\r\n//----------------------------------------------------------------------\r\n//\r\n\r\nlet message;\r\n\r\nif (login == \"Сотрудник\") {\r\n  message = \"Привет\";\r\n} else if (login == \"Директор\") {\r\n  message = \"Здравствуйте\";\r\n} else if (login == \"\") {\r\n  message = \"Нет логина\";\r\n} else {\r\n  message = \"\";\r\n}\r\n\r\n//|\r\n//v\r\n\r\nmessage =\r\n  login == \"Сотрудник\"\r\n    ? (message = \"Привет\")\r\n    : login == \"Директор\"\r\n    ? (message = \"Здравствуйте\")\r\n    : login == \"\"\r\n    ? (message = \"Нет логина\")\r\n    : (message = \"\");\r\n\r\n//\r\n//----------------------------------------------------------------------\r\n//\r\n\r\nswitch (browser) {\r\n  case \"Edge\":\r\n    alert(\"You've got the Edge!\");\r\n    break;\r\n\r\n  case \"Chrome\":\r\n  case \"Firefox\":\r\n  case \"Safari\":\r\n  case \"Opera\":\r\n    alert(\"Okay we support these browsers too\");\r\n    break;\r\n\r\n  default:\r\n    alert(\"We hope that this page looks ok!\");\r\n}\r\n\r\n//|\r\n//v\r\n\r\nif (browser == \"Edge\") {\r\n  alert(\"You`ve got the Edge!\");\r\n} else if (\"Chrome\") {\r\n} else if (\"Firefox\") {\r\n} else if (\"Safari\") {\r\n} else if (\"Opera\") {\r\n  alert(\"Okay we support these browsers too\");\r\n} else {\r\n  alert(\"We hope that this page looks ok!\");\r\n}\r\n\r\n//\r\n//----------------------------------------------------------------------\r\n//\r\nconst number = +promt(\"Введите число между 0 и 3\", \"\");\r\nif (number === 0) {\r\n  alert(\"Вы ввели число 0\");\r\n}\r\nif (number === 1) {\r\n  alert(\"Вы ввели число 1\");\r\n}\r\nif (number === 2 || number === 3) {\r\n  alert(\"Вы ввели число 2, а может и 3\");\r\n}\r\n\r\n//|\r\n//v\r\n\r\nswitch (number) {\r\n  case value:\r\n    alert(\"Вы ввели число 0\");\r\n    break;\r\n  case 1:\r\n    alert(\"Вы ввели число 1\");\r\n    break;\r\n  case 2:\r\n  case 3:\r\n    alert(\"Вы ввели число 2, а может и 3\");\r\n}\r\n\r\n//\r\n//----------------------------------------------------------------------\r\n//\r\n\r\nfunction checkAge(age) {\r\n  if (age > 18) {\r\n    return true;\r\n  } else {\r\n    return comfirm(\"Родители разрешили?\");\r\n  }\r\n}\r\n\r\nfunction checkAge1(age) {\r\n  if (age > 18) {\r\n    return true;\r\n  }\r\n  return confirm(\"Ротдители разрешили?\");\r\n}\r\n\r\n//\r\n//----------------------------------------------------------------------\r\n//\r\nfunction checkAge2() {\r\n  if (age > 18) {\r\n    return true;\r\n  } else confirm(\"Родители разрешили?\");\r\n}\r\nfunction checkAge(age) {\r\n  return age > 18 ? true : confirm(\"Родители разрешили\");\r\n}\r\nfunction min(a, b) {\r\n  if (a < b) {\r\n    return a;\r\n  } else {\r\n    return b;\r\n  }\r\n}\r\n\r\n//\r\n//----------------------------------------------------------------------\r\n//\r\n\r\nfunction pow(x, n) {\r\n  let result = x;\r\n  for (let i = 1; i < n; ) {\r\n    result *= x;\r\n  }\r\n  return result;\r\n}\r\nlet x = prompt(\"x?\", \"\");\r\nlet n = prompt(\"n?\", \"\");\r\nif (n >= 1 && n % 1 === 0) {\r\n  alert(pow(x, n));\r\n} else {\r\n  alert(`Степень ?${n} не поддерживается, используйте натуральное число`);\r\n}\r\n\r\n//\r\n//----------------------------------------------------------------------\r\n//\r\n\r\nfunction ask(question, yes, no) {\r\n  if (confirm(question)) yes();\r\n  else no();\r\n}\r\nask(\r\n  \"Вы согласны?\",\r\n  function () {\r\n    alert(\"Вы согласились.\");\r\n  },\r\n  function () {\r\n    alert(\"Вы отменили выполнение.\");\r\n  }\r\n);\r\n\r\n//|\r\n//v\r\nlet func = (question, yes, no) => {\r\n  if (confirm(question)) yes();\r\n  else no();\r\n};\r\nfunc(\r\n  \"Вы согласны?\",\r\n  () => alert(\"Вы согласились.\"),\r\n  () => alert(\"Вы отменили выполнение.\")\r\n);\r\n\r\n//\r\n//----------------------------------------------------------------------\r\n//\r\n\r\nuser = {\r\n  name: \"John\",\r\n  surname: \"Smith\",\r\n};\r\nuser.name = \"Pete\";\r\ndelete user.name;\r\n\r\nlet schedule = {};\r\n\r\nlet isEmpty = (obj) => {\r\n  return obj.lenght > 0 ? true : false;\r\n};\r\n\r\nalert(isEmpty(schedule));\r\n\r\nschedule[\"8:30\"] = \"get up\";\r\n\r\nalert(isEmpty(schedule));\r\n\r\n//\r\n//----------------------------------------------------------------------\r\n//\r\n\r\nconst user = {\r\n  name: \"Jogn\",\r\n};\r\n\r\nuser.name = \"Pete\";\r\n//\r\n//----------------------------------------------------------------------\r\n//\r\n\r\nlet salaries = {\r\n  John: 100,\r\n  Ann: 160,\r\n  Pete: 130,\r\n};\r\nlet sumObject = (obj) => {\r\n  let sum = 0;\r\n  for (let key in obj) {\r\n    sum += obj[key];\r\n  }\r\n};\r\nsumObject(salaries);\r\n//\r\n//----------------------------------------------------------------------\r\n//\r\n\r\nmultiplyNumeric = (obj) => {\r\n  for (let key in obj) {\r\n    if (obj.key.typeof == \"number\") {\r\n      obj.key *= 2;\r\n    }\r\n  }\r\n};\r\nlet menu = {\r\n  width: 200,\r\n  height: 300,\r\n  title: \"My menu\",\r\n};\r\nmultiplyNumeric(menu);\r\n\r\n//\r\n//----------------------------------------------------------------------\r\n//\r\n\r\nfunction marry(man, woman) {\r\n  woman.husband = man;\r\n  man.wife = woman;\r\n  return {\r\n    father: man,\r\n    mother: woman,\r\n  };\r\n}\r\n\r\nlet family = marry(\r\n  {\r\n    name: \"John\",\r\n  },\r\n  {\r\n    name: \"Ann\",\r\n  }\r\n);\r\n\r\n//\r\n//----------------------------------------------------------------------\r\n//\r\n\r\nlet user = { name: \"John\" };\r\nlet admin = { name: \"Admin\" };\r\n\r\nfunction sayHi() {\r\n  alert(this.name);\r\n}\r\n\r\nuser.f = sayHi;\r\nadmin.f = sayHi;\r\n\r\nuser.f(); //john\r\nadmin.f(); //admin\r\n\r\n//\r\n//----------------------------------------------------------------------\r\n//\r\n\r\nfunction makeUser() {\r\n  return {\r\n    name: \"John\",\r\n    ref: this,\r\n  };\r\n}\r\n\r\nlet user = makeUser();\r\n\r\nalert(user.ref.name); // error\r\n\r\n//\r\n//----------------------------------------------------------------------\r\n//\r\n\r\nlet calculator = {\r\n  read(a) {\r\n    this.a = a;\r\n    this.b = b;\r\n  },\r\n  sum() {\r\n    return this.a + this.b;\r\n  },\r\n  mul() {\r\n    return this.a * this.b;\r\n  },\r\n};\r\n\r\ncalculator.read();\r\nalert(calculator.sum());\r\nalert(calculator.mul());\r\n//\r\n//----------------------------------------------------------------------\r\n//\r\n\r\nlet ladder = {\r\n  step: 0,\r\n  up() {\r\n    this.step++;\r\n    return this;\r\n  },\r\n  down() {\r\n    this.step--;\r\n    return this;\r\n  },\r\n  showStep: function () {\r\n    alert(this.step);\r\n    return this;\r\n  },\r\n};\r\n\r\n//\r\n//----------------------------------------------------------------------\r\n//\r\n//Это функция конструктор\r\n//На самом деле это обычная функция но есть соглашение что\r\n//функция-конструктор вызывается только с помощью оператора new\r\n//наименование обязательно с большой буквый\r\n//Все кроме стрелочных функций можно использовать с new как конструктор\r\n//Так как внутри стрелочной функции нет this\r\n\r\n//\r\n//Что делает new на самом деле\r\n//\r\n// function User(){\r\n//   this = {}\r\n//   this.name = name\r\n//   this.isAdmin = false\r\n//   return this\r\n// }\r\n//\r\n\r\nfunction User() {\r\n  this.name = name;\r\n  this.isAdmin = false;\r\n}\r\n\r\nlet user = new User(\"Jack\");\r\n\r\nalert(user.name);\r\nalert(user.isAdmin);\r\n\r\n//\r\n//----------------------------------------------------------------------\r\n//\r\n\r\nfunction User(name) {\r\n  this.name = name;\r\n\r\n  this.sayHi = function () {\r\n    alert(\"Меня зовут\" + this.name);\r\n  };\r\n}\r\nlet john = new User(\"John\");\r\n\r\njohn.sayHi();\r\n\r\n//\r\n//----------------------------------------------------------------------\r\n//\r\nlet obj = {};\r\n\r\nfunction A() {\r\n  return obj;\r\n}\r\nfunction B() {\r\n  return obj;\r\n}\r\n\r\nlet a = new A();\r\nlet b = new B();\r\n\r\nalert(a == b);\r\n\r\n//\r\n//----------------------------------------------------------------------\r\n//\r\nfunction Calculator() {\r\n  this.read = function () {\r\n    this.a = promt(\"Введите число a\");\r\n    this.b = promt(\"Введите число б\");\r\n  };\r\n  this.sum = function () {\r\n    return this.a + this.b;\r\n  };\r\n  this.mul = function () {\r\n    return this.a * this.b;\r\n  };\r\n}\r\n\r\nlet calculator1 = new Calculator();\r\ncalculator1.read();\r\n\r\nalert(\"Sum=\" + calculator1.sum());\r\nalert(\"Mul=\" + calculator1.mul());\r\n\r\n//\r\n//----------------------------------------------------------------------\r\n//\r\nfunction Accumulator(startingValue) {\r\n  this.value = startingValue;\r\n  this.read = function () {\r\n    this.value += promt(\"Введите число\");\r\n  };\r\n}\r\n\r\nlet accumulator = new Accumulator(1);\r\n\r\naccumulator.read();\r\naccumulator.read();\r\n\r\nalert(accumulator.value);\r\n\r\n//\r\n//----------------------------------------------------------------------\r\n//\r\n\r\nlet user = {\r\n  name: \"John\",\r\n  money: 1000,\r\n  [Symbol.toPrimitive](hint) {\r\n    alert(`hint: ${hint}`);\r\n    return hint == \"string\" ? `name:\"${this.name}\"` : this.money;\r\n  },\r\n};\r\n// демонстрация результатов преобразований:\r\nalert(user); // hint: string -> {name: \"John\"}\r\nalert(+user); // hint: number -> 1000\r\nalert(user + 500); // hint: default -> 1500\r\n\r\n//\r\n//----------------------------------------------------------------------\r\n//\r\n\r\nlet user = {\r\n  name: \"John\",\r\n  money: 1000,\r\n  toString() {\r\n    return `{name:\"${this.name}\"}`;\r\n  },\r\n  valueOf() {\r\n    return this.money;\r\n  },\r\n};\r\n\r\n//\r\n//----------------------------------------------------------------------\r\n//\r\n",
  "task4.js": "let str = \"Привет\";\r\n\r\nstr.test = 5;\r\n\r\nalert(str); // Привет // неправильно выдаст ошибку\r\n\r\n// В зависимости от того, используете ли вы строгий режим (use strict) или нет, результат может быть:\r\n\r\n// undefined (без strict)\r\n// Ошибка (strict mode)\r\n// Почему? Давайте посмотрим что происходит в строке кода, отмеченной (*):\r\n\r\n// В момент обращения к свойству str создаётся «объект-обёртка».\r\n// В строгом режиме, попытка изменения этого объекта выдаёт ошибку.\r\n// Без строгого режима, операция продолжается, объект получает свойство test, но после этого он удаляется, так что на последней линии str больше не имеет свойства test.\r\n// Данный пример наглядно показывает, что примитивы не являются объектами.\r\n\r\n// Они не могут хранить дополнительные данные.\r\n\r\n//\r\n//----------------------------------------------------------------------\r\n//\r\n\r\nlet a = +promt(\"Введите число а\");\r\n\r\nlet b = +promt(\"Введите число b\");\r\n\r\nalert(a + b);\r\n\r\n//\r\n//----------------------------------------------------------------------\r\n//\r\n\r\nalert(Math.round((6.35 * 10) / 10));\r\n\r\n//\r\n//----------------------------------------------------------------------\r\n//\r\n\r\nfunction readNumber() {\r\n  let a;\r\n\r\n  do {\r\n    prompt(\"Введите число\");\r\n  } while (!isFinite(a));\r\n  if (a == null || num == \"\") return +a;\r\n}\r\n\r\n//\r\n//----------------------------------------------------------------------\r\n//\r\n\r\nfunction random(min, max) {\r\n  return min + Math.random() * (max - min);\r\n}\r\nrandom(1, 10);\r\n//\r\n//----------------------------------------------------------------------\r\n//\r\n\r\nfunction randInteger(min, max) {\r\n  Math.round((min + Math.random() * (max - min)) * 10); // неправильно\r\n\r\n  let rand = min + Math.random() * (max + 1 - min);\r\n  return Math.floor(rand);\r\n}\r\n\r\n//\r\n//----------------------------------------------------------------------\r\n//\r\n\r\nfunction ucFirst(str) {\r\n  const firstSimbol = str.at(0).toUpperCase();\r\n  return firstSimbol + str.slice(1);\r\n}\r\nconsole.log(ucFirst(\"Вася\"));\r\n\r\n//\r\n//----------------------------------------------------------------------\r\n//\r\n\r\nfunction checkSpam(str) {\r\n  const lowerCase = toLowerCase(str);\r\n  switch (lowerCase) {\r\n    case \"viagra\":\r\n      return true;\r\n    case \"xxx\":\r\n      return true;\r\n\r\n    default:\r\n      return false;\r\n  }\r\n}\r\n\r\n//\r\n//----------------------------------------------------------------------\r\n//\r\n",
  "test2.js": "let fruits = [\"Яблоки\", \"Груша\", \"Апельсин\"];\r\n\r\nlet shoppingCart = fruits;\r\n\r\nshoppingCart.push(\"Банан\");\r\n\r\nconsole.log(fruits.length); //4\r\n\r\nlet styles = [\"Джаз\", \"Блюз\"];\r\nstyles.push(\"Рок-н-ролл\");\r\nstyles[Math.floor(styles.length - 1 / 2)] = \"Классика\";\r\nconsole.log(styles.shift());\r\nstyles.unshift(\"Рэп\", \"Рэгги\");\r\n\r\nlet arr = [\"a\", \"b\"];\r\n\r\narr.push(function () {\r\n  console.log(this);\r\n});\r\narr[2]; //результат\r\n//a,b,function(){\r\n//    console.log(this)\r\n//}\r\n// function sumInput() {\r\n//   let arr = [];\r\n//   let i;\r\n//   do {\r\n//     i = prompt();\r\n//     if ((i == \"\", i == null)) {\r\n//       return arr;\r\n//     }\r\n//     arr.push(i);\r\n//   } while (true);\r\n// }\r\n// console.log(sumInput());\r\n\r\nfunction getMaxSubSum(arr) {\r\n  let groupSum;\r\n  let maxSum = 0;\r\n  for (let groupLenght = 0; groupLenght < arr.length; groupLenght++) {\r\n    groupSum = 0;\r\n    for (let second = 0; second < arr.length - groupLenght; second++) {\r\n      groupSum = getGroupSum(arr, second, second + groupLenght + 1);\r\n\r\n      // for (let third = second; third < groupLenght; third++) {\r\n\r\n      // }\r\n\r\n      if (maxSum < groupSum) {\r\n        maxSum = groupSum;\r\n      }\r\n    }\r\n  }\r\n  return maxSum;\r\n}\r\nconsole.log(getMaxSubSum([-1, 2, 3, -9]));\r\nconsole.log(getMaxSubSum([2, -1, 2, 3, -9]));\r\nconsole.log(getMaxSubSum([-1, 2, 3, -9, 11]));\r\nconsole.log(getMaxSubSum([-2, -1, 1, 2]));\r\nconsole.log(getMaxSubSum([100, -9, 2, -3, 5]));\r\nconsole.log(getMaxSubSum([1, 2, 3]));\r\nconsole.log(getMaxSubSum([1, -2, 3, 4, -5, 6]));\r\nconsole.log(getMaxSubSum([-1, -2, -3, -4, -5]));\r\nconsole.log(getMaxSubSum([5, 1, -2, 3, 4, -1, 2]));\r\nconsole.log(getMaxSubSum([10, 6, -5, 6]));\r\nconsole.log(getMaxSubSum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]));\r\nconsole.log(getMaxSubSum([-1, 2, 3, -9, 4, 5, -1, 2]));\r\n//Ищем по группам т.е берем группу длинной в 1 попорядку проверяем\r\n//потом берем группу длинной в 2 проверяем каждую\r\n//берем группу длинной в 3 проверяем каждую\r\n//максимальная группа будет равна длине массива\r\n//\r\nfunction getGroupSum(arr, index1, index2) {\r\n  let newArr = arr.slice(index1, index2);\r\n  let sum = 0;\r\n  newArr.forEach((element) => {\r\n    sum += element;\r\n  });\r\n  return sum;\r\n}\r\n\r\n// function unique(arr) {\r\n//   let set = new Set();\r\n//   arr.forEach((element) => {\r\n//     set.add(element)\r\n//   });\r\n//   return set\r\n// }\r\n\r\nfunction unique() {\r\n  return Array.from(new Set(arr));\r\n}\r\nlet values = [\r\n  \"Hare\",\r\n  \"Krishna\",\r\n  \"Hare\",\r\n  \"Krishna\",\r\n  \"Krishna\",\r\n  \"Krishna\",\r\n  \"Hare\",\r\n  \"Hare\",\r\n  \":-O\",\r\n];\r\n\r\n// alert(unique(values));\r\n\r\n// function aclean(arr) {\r\n//   // let sotrted = arr.filter(function(values){\r\n//   //     values.\r\n//   // })\r\n//   let result = [...arr];\r\n//   for (let index = 0; index < arr.length; index++) {\r\n//     const element = arr[index].split(\"\").sort().join(\"\");\r\n//     for (let indexInner = 0; indexInner < arr.length; indexInner++) {\r\n//       const elementInner = arr[indexInner].split(\"\").sort().join(\"\");\r\n//       if (element == elementInner && index != indexInner) {\r\n//         console.log(result[indexInner]);\r\n//         result.splice(\r\n//           result.findIndex(\r\n//             (e) =>\r\n//               e.split(\"\").sort().join(\"\") ==\r\n//               elementInner.split(\"\").sort().join(\"\")\r\n//           ),\r\n//           1\r\n//         );\r\n//         // console.log(element + \" \" + elementInner);\r\n//         // console.log(index + \" \" + indexInner + (element == elementInner));\r\n//       }\r\n//     }\r\n//   }\r\n//   return result;\r\n// }\r\n//хрень реализация логически так хотел но индексы съезжают\r\n\r\nfunction aclean(arr) {\r\n  // console.log(arguments);\r\n  //console.dir(this);\r\n  //console.dir(aclean);\r\n  console.log(arr);\r\n  // console.dir(arguments.callee);\r\n  // console.dir(arguments.caller);\r\n  // console.dir(aclean);\r\n  // console.log(arguments);\r\n  // console.log(Object.getOwnPropertyNames(aclean));\r\n  // console.log(aclean.arguments);\r\n  // console.log(aclean.caller);\r\n  // console.log(aclean.name);\r\n  // console.log(aclean.prototype);\r\n  let set = new Set();\r\n  let result = [];\r\n  arr.forEach((e) => {\r\n    set.add(e.split(\"\").sort().join(\"\").toLowerCase());\r\n  });\r\n  //отсортирвал по оригинальности при помощи .add  у set\r\n  set.forEach((element) => {\r\n    result.push(\r\n      arr[\r\n        arr.findIndex(\r\n          (e) => element == e.split(\"\").sort().join(\"\").toLowerCase()\r\n        )\r\n      ]\r\n    );\r\n  });\r\n\r\n  return result;\r\n}\r\nlet arr1 = [\"nap\", \"teachers\", \"cheaters\", \"PAN\", \"ear\", \"era\", \"hectares\"];\r\n// aclean.apply(arr1, arr1);\r\naclean.call(\r\n  null,\r\n  [\"nap\", \"teachers\", \"cheaters\", \"PAN\", \"ear\", \"era\", \"hectares\"],\r\n  [\"nap\", \"teachers\", \"cheaters\", \"PAN\", \"ear\", \"era\", \"hectares\"]\r\n);\r\naclean.apply(\r\n  null,\r\n  [\"nap\", \"teachers\", \"cheaters\", \"PAN\", \"ear\", \"era\", \"hectares\"],\r\n  [\"nap\", \"teachers\", \"cheaters\", \"PAN\", \"ear\", \"era\", \"hectares\"]\r\n);\r\n// aclean(arr1);\r\n// let result = [...array]\r\n// array.forEach(element => {\r\n//     element = toString(element)\r\n//     values.forEach(value => {\r\n//         value = toString(value)\r\n//         if (element === value){\r\n//             result.splice(result.indexOf(element), 1)\r\n//         }\r\n//     })\r\n// });\r\n// return result\r\nlet func1 = (arg) => {\r\n  console.log(Object.getOwnPropertyNames(func1));\r\n  // console.log(arguments);\r\n  let i = 0;\r\n  // console.log(arguments);\r\n  //Uncaught ReferenceError: arguments is not defined\r\n};\r\nfunc1.b = 1;\r\nfunc1(\"123\");\r\nconsole.dir(func1);\r\n\r\n// console.log(func1.arguments);\r\n"
};